<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    
    
    <title>docker一本通 + nginx | Yoyo&#39;s blog</title>
    
    <link rel="alternative" href="/atom.xml" title="Yoyo&#39;s blog" type="application/atom+xml">
    
    
<link rel="stylesheet" href="/css/style.css">

    
    <link rel="stylesheet" href="/libs/fancybox/jquery.fancybox.css" charset="utf-8">
    
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
<!-- hexo injector head_end start --><script src="./func.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>
<body class="site">
    <!-- 遮罩层 -->
    <div id="mask-layer">
    </div>
    
    <header class="site-header">
        <h1 class="site-title"><a href="/">Yoyo&#39;s blog</a></h1>
        <nav class="site-nav">
            <ul class="nav">
                
                <li><a href="/">Home</a></li>
                
                <li><a href="/archives">Archives</a></li>
                
                
                <li><a href="/atom.xml" title="RSS Feed">rss</a></li>
                
                <li><a class="toggle-search" href="#search">search</a></li>
            </ul>
        </nav>
        <div class="site-search" id="search">
            <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="https://70v-yoyo.github.io"></form>
        </div>
        
            <div class="site-header-background" style="background-image:url('http://reumia.github.io/hexo-theme-zzoman2015/images/background-zzoman2015.jpg')"></div>
        
    </header>
    <div class="site-body">
        <div class="global-width">
    <article class="article" data-layout="post" data-slug="docker一本通">
        <div class="article-content">
            
            
            <header class="article-header">
                <div class="article-meta">
                    <a href="/2025/07/14/docker%E4%B8%80%E6%9C%AC%E9%80%9A/" class="article-date">
  <time datetime="2025-07-14T03:38:30.000Z">2025-07-14</time>
</a>
                    
                    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/frontend/" rel="tag">frontend</a></li></ul>

                </div>
                
    <h1 class="article-title" itemprop="name">
      <a href="/2025/07/14/docker%E4%B8%80%E6%9C%AC%E9%80%9A/">docker一本通 + nginx</a>
    </h1>

            </header>
            
            <div class="article-body">
                <meta name="referrer" content="no-referrer" />

<blockquote>
<p>版本：250711</p>
</blockquote>
<h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><ul>
<li>docker是⼀个应⽤级隔离的虚拟化技术，将 Node + 项目代码 + 依赖打包成一个镜像，可以一键运行，无论在谁的电脑上都一样。</li>
<li>作用</li>
</ul>
<table>
<thead>
<tr>
<th>传统部署</th>
<th>用 Docker 的部署</th>
</tr>
</thead>
<tbody><tr>
<td>配服务器环境很烦</td>
<td>镜像里环境打包好了</td>
</tr>
<tr>
<td>项目跑不起来</td>
<td>哪怕系统不同，也能统一运行</td>
</tr>
<tr>
<td>很难一键部署</td>
<td>镜像打完一条命令跑起来</td>
</tr>
</tbody></table>
<ul>
<li>docker三大核心概念<br>镜像images：是具有源的所有特征的⼀个标记⽂件<blockquote>
<p>镜像在哪搜？<br>在 Docker Desktop 界面中搜索：打开 Docker Desktop，在左侧导航栏中选择 “Images”，然后点击 “Pull” 按钮。在弹出的对话框中输入关键词，如 “windows” 或具体的 Windows 版本号，如 “windows10”“windows server 2019” 等进行搜索。根据搜索结果，选择合适的镜像并点击 “OK” 按钮开始下载。<br>使用命令行搜索：打开命令行终端（如 PowerShell 或 Command Prompt），输入docker search &lt;镜像关键词&gt;命令进行搜索。例如，要搜索 Windows Server 相关的镜像，可以输入docker search windows server。该命令会在 Docker Hub 上搜索相关镜像，并在终端中显示镜像名称、描述、星级评分等信息，用户可根据这些信息选择所需镜像。<br>在 Docker Hub 网站上查找：访问Docker Hub 官方网站，在搜索栏中输入 Windows 镜像相关的关键词进行搜索。找到合适的镜像后，记录下镜像名称，然后在 Docker Desktop 中通过命令行或界面进行拉取。<br>除了 Docker Hub，一些其他的镜像仓库也可能提供 Windows 镜像，不过需要确保这些仓库的可靠性和安全性。同时，如果你所在的企业或组织有内部的私有镜像仓库，也可以在其中查找 Windows 镜像，只需将 Docker Desktop 配置为连接到该私有仓库即可。</p>
</blockquote>
</li>
</ul>
<p>仓库：存放镜像⽂件的⽬录</p>
<blockquote>
<p>Docker Hub和常用镜像管理方式<br>登录Docker Hub，创建和使用Hub镜像仓库（需解决网络问题）<br>使用阿里云个人版镜像服务<br>也可配置国内其他镜像源</p>
</blockquote>
<p>容器container：docker驱动根据镜像⽂件恢复出来⼀个具体环境</p>
<ul>
<li>docker与虚拟机区别<br>Docker 是“应用级虚拟化”，VM 是“系统级虚拟化”。</li>
</ul>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>Docker（容器）</th>
<th>虚拟机（VM）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心机制</strong></td>
<td>直接运行在宿主机内核之上（共享 OS 内核）</td>
<td>在虚拟硬件上运行一个完整操作系统</td>
</tr>
<tr>
<td><strong>是否包含操作系统</strong></td>
<td>❌ 不包含操作系统，仅打包应用和依赖</td>
<td>✅ 包含完整操作系统</td>
</tr>
<tr>
<td><strong>资源占用</strong></td>
<td>轻量，占用少（启动快）</td>
<td>占用多（系统级资源，如 RAM、CPU）</td>
</tr>
<tr>
<td><strong>启动速度</strong></td>
<td>秒级启动</td>
<td>通常需要几十秒甚至几分钟</td>
</tr>
<tr>
<td><strong>体积大小</strong></td>
<td>小（几十 MB）</td>
<td>大（几 GB）</td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td>几乎无开销（接近原生）</td>
<td>有明显开销（虚拟化层 + Guest OS）</td>
</tr>
<tr>
<td><strong>可移植性</strong></td>
<td>高（镜像可快速部署到任何支持 Docker 的平台）</td>
<td>中（需要迁移整个 VM）</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>强（基于内核命名空间和 cgroups）</td>
<td>更强（操作系统级别完全隔离）</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>相对较弱（共用宿主内核）</td>
<td>更强（各 VM 内核隔离）</td>
</tr>
<tr>
<td><strong>适合场景</strong></td>
<td>快速部署、微服务、CI&#x2F;CD、DevOps</td>
<td>操作系统级虚拟化、运行异构系统（如 Windows 上跑 Linux）</td>
</tr>
<tr>
<td><strong>典型代表</strong></td>
<td>Docker、Podman、containerd</td>
<td>VMware、VirtualBox、Hyper-V</td>
</tr>
</tbody></table>
<ol>
<li>安装虚拟机软件如：VMware，在此虚拟机软件上安装操作系统（下载），把操作系统的虚拟机文件备份，随时复制并启动该操作系统。</li>
<li>在Linux上安装Docker软件，从镜像仓库拉取（Pull）操作系统或应用环境，基于该镜像文件创建一个容器（运行环境），备份容器以供下次使用（直接export容器，将容器提交（Commit）为本地镜像）。</li>
<li>虚拟机环境直接完全模拟一套全新的硬件环境，Docker环境不虚拟硬件，直接使用宿主机资源（Docker默认下不限制CPU，内存资源），也可以直接指定分配某个容器的CPU或内存资源。</li>
<li>虚拟机可以直接与宿主机或局域网连接，分配IP地址（Brige桥接方式，NAT方式），Docker容器无法获取IP地址（跟随于宿主机的IP地址）。</li>
<li>镜像相当于是容器的模板，通过镜像创建容器，容器修改后也可提交为镜像，删除容器并不会删除镜像，删除镜像则无法创建容器。</li>
</ol>
<ul>
<li>容器使用注意事项：</li>
</ul>
<ol>
<li>尽量让一个容器做一件事情，或启动一个服务。</li>
<li>尽量使用挂载方式将数据文件挂载到容器中，容器里面尽量不要保存数据。</li>
<li>尽量让容器按照Docker化要求来使用，而不是安装一个虚拟机。</li>
<li>尽量不使用交互模式直接操作容器，而是在宿主机上执行命令，或者使用Docker File。</li>
</ol>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><table>
<thead>
<tr>
<th>系统</th>
<th>推荐安装方式</th>
<th>包管理工具</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Ubuntu &#x2F; Debian</strong></td>
<td><code>apt</code> 安装（推荐）</td>
<td><code>apt</code></td>
</tr>
<tr>
<td><strong>CentOS &#x2F; Rocky &#x2F; RHEL</strong></td>
<td><code>dnf</code> 或 <code>yum</code> 安装</td>
<td><code>dnf</code>, <code>yum</code></td>
</tr>
<tr>
<td><strong>Alpine Linux</strong></td>
<td><code>apk</code> 安装</td>
<td><code>apk</code></td>
</tr>
<tr>
<td><strong>macOS</strong></td>
<td>Homebrew 安装 或 Docker Desktop</td>
<td><code>brew</code></td>
</tr>
<tr>
<td><strong>Windows</strong></td>
<td>Docker Desktop 安装</td>
<td>GUI 安装包</td>
</tr>
<tr>
<td><strong>所有系统通用</strong></td>
<td>官方一键安装脚本</td>
<td>curl</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker --version         <span class="comment"># 查看版本</span></span><br><span class="line">docker info              <span class="comment"># 查看 Docker 系统信息</span></span><br><span class="line">docker run hello-world   <span class="comment"># 拉一个测试镜像，看看是否能正常运行</span></span><br></pre></td></tr></table></figure>
<ul>
<li>docker build 和 docker run 区别：</li>
</ul>
<ol>
<li>功能用途<br>docker build：根据 Dockerfile 来构建 Docker 镜像。Dockerfile 是一个文本文件，其中包含了一系列的指令，例如指定基础镜像、安装软件包、复制文件等。docker build 按照 Dockerfile 中的指令逐步执行，最终生成一个新 Docker 镜像。<br>docker run：基于已有Docker 镜像创建并启动一个新容器。容器是镜像的一个运行实例，轻量级的、独立的操作系统环境，可以运行应用程序。</li>
<li>执行时机<br>docker build：通常在开发和部署前期使用，当你需要创建一个自定义的 Docker 镜像时，就会使用该命令。比如你开发了一个 Python 应用，需要将其打包成一个 Docker 镜像，就可以编写一个 Dockerfile 并使用 docker build 命令来构建镜像。<br>docker run：镜像构建完成之后使用，已经有可用的 Docker 镜像，使用 docker run 命令来启动一个容器，让应用程序在容器中运行。</li>
</ol>
<p>docker build：常见参数有 -t 用于给镜像指定一个标签（名称和版本），-f 用于指定 Dockerfile 的路径等。例如：<code>docker build -t myapp:1.0 .</code> 注意最后的那个<code>.</code>，表示在当前目录（.）下查找 Dockerfile 并构建一个名为 myapp 版本为 1.0 的镜像。</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ol>
<li>拉取镜像：docker pull hello-world，默认情况下，会拉取最新版本镜像(latest)，如果需要拉取指定版本，则必须指定TAG标签。</li>
<li>创建运行容器：docker run hello-world    &#x3D;&#x3D;  docker create+ docker start</li>
<li>查看镜像：docker images<br>–name   自定义容器名<br>-p ： 映射端口号，宿主机端口：容器端口<br>-d ：将进程置于后台执行<br>-it：前台运⾏交互模式<br>-v ：挂载外部⽬录， 语法： -v 主机⽬录:容器⽬录<br>-e : 设置环境变量， 语法： -e 变量名&#x3D;值</li>
<li>查看容器：docker ps  查看运行的容器， docker container ls -a  查看所有的容器</li>
<li>启停容器：docker start&#x2F;stop&#x2F;restart hello-world（容器名）</li>
<li>查看容器⽇志的命令： docker logs 容器名</li>
<li>删除容器：docker rm 容器名 （可通过container ls -a查看）</li>
<li>删除镜像：docker rmi hello-world</li>
<li>使用交互模式进入容器：docker exec -it tomcat-8.0 bash<br>-i  ： 使用交互模式    -t：指定一个终端<br>bash 解释命令所⽤的解释器<br>推出容器：exit</li>
<li>在宿主机上直接操作容器：<code>dcoker exec  -t  mysql-5.6  ip a</code><br>这条命令是在 执行容器内的命令，并且是一次性运行的，不需要额外分步执行。<br>它会直接在容器内运行 ip a 命令，并输出容器内的网络接口信息。没有必要手动进入容器后再执行 ip a，因为 docker exec 会自动为你在容器中执行该命令。<br>如果你希望进入容器并交互式执行多个命令，你可以使用 docker exec -it mysql-5.6 bash 进入容器的终端，然后手动执行 ip a 或其他命令。</li>
<li>把容器导出到本地保存<br>docker export -o test.tar  容器名</li>
<li>将本地的容器文件上传到docker服务作为镜像,存放在镜像仓库中<br>docker import test.tar 镜像名:TAG<br>:TAG 是 镜像的标签，用来指定该镜像的版本或标识符。<br>TAG：是镜像的版本标签，通常用于标识镜像的不同版本。例如，latest、v1.0 或任何你自己设定的标签。如果没有指定 TAG，默认的标签是 latest。</li>
<li>在宿主机和容器之间拷⻉⽂件<br><code>docker cp 宿主机的路径 容器名：容器中的⽬标路径</code><br>如果要从容器⾥⾯拷⻉⽂件出来，交换路径的位置<br>注意事项：容器的路径需要带上容器名<br>拷⻉⽬录的时候，不需要加 -r这类的参数</li>
<li>直接将容器上传作为本地镜像文件<br>docker commit 容器名 镜像名:TAG<br><code>docker commit -p -a &quot;作者名字&quot; -m&quot;描述&quot; 容器编号 镜像名:版本号</code><br>例如：docker commit -p -a “lency” -m”my_rabbit” e28f77161d0d my_rabbit:v1<br>把容器提交为镜像，便于传递<br>注意：执⾏命令前，停⽌相应的容器</li>
<li>docker save&#x2F;load（镜像备份&#x2F;恢复）</li>
</ol>
<h1 id="Dockerfile编写"><a href="#Dockerfile编写" class="headerlink" title="Dockerfile编写"></a>Dockerfile编写</h1><ul>
<li>作用<br>定义 Docker 镜像构建过程的文本文件。<br>它是一份脚本，告诉 Docker 如何一步步搭建你的应用环境。<br>包括基础镜像、安装依赖、复制代码、运行命令等操作。<br>最终由 Docker 根据 Dockerfile 自动构建出一个镜像。</li>
<li>使用</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择基础镜像（Node.js 16）</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 package.json 和 yarn.lock </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json yarn.lock ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖 或者RUN npm install</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yarn install --frozen-lockfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制项目代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建项目（假设是前端）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yarn build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口（比如 3000）</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动时运行命令 或CMD [&quot;npm&quot;, &quot;start&quot;]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;dist/server.js&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>常用命令<br>1）镜像 image</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker build -t 名字 .</code></td>
<td>构建镜像</td>
<td><code>docker build -t my-app .</code></td>
</tr>
<tr>
<td><code>docker images</code></td>
<td>查看所有本地镜像</td>
<td>-</td>
</tr>
<tr>
<td><code>docker rmi 镜像名/ID</code></td>
<td>删除镜像</td>
<td><code>docker rmi my-app</code></td>
</tr>
<tr>
<td><code>docker pull 镜像名[:tag]</code></td>
<td>拉取镜像（如 nginx）</td>
<td><code>docker pull node:18</code></td>
</tr>
</tbody></table>
<p>2）容器 container</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker run</code></td>
<td>启动一个容器</td>
<td><code>docker run -d -p 3000:3000 my-app</code></td>
</tr>
<tr>
<td><code>docker ps</code></td>
<td>查看运行中的容器</td>
<td>-</td>
</tr>
<tr>
<td><code>docker ps -a</code></td>
<td>查看所有容器（含已停止）</td>
<td>-</td>
</tr>
<tr>
<td><code>docker stop 容器名/ID</code></td>
<td>停止容器</td>
<td><code>docker stop my-container</code></td>
</tr>
<tr>
<td><code>docker start 容器名</code></td>
<td>启动已停止的容器</td>
<td><code>docker start my-container</code></td>
</tr>
<tr>
<td><code>docker restart 容器名</code></td>
<td>重启容器</td>
<td><code>docker restart my-container</code></td>
</tr>
<tr>
<td><code>docker rm 容器名</code></td>
<td>删除容器</td>
<td><code>docker rm my-container</code></td>
</tr>
<tr>
<td><code>docker rm -f 容器名</code></td>
<td>强制删除运行中容器</td>
<td><code>docker rm -f my-container</code></td>
</tr>
<tr>
<td><code>docker exec -it 容器名 bash</code></td>
<td>进入容器终端</td>
<td><code>docker exec -it my-container bash</code></td>
</tr>
<tr>
<td><code>docker logs 容器名</code></td>
<td>查看容器日志</td>
<td><code>docker logs my-container</code></td>
</tr>
<tr>
<td><code>docker logs -f 容器名</code></td>
<td>实时查看日志（tail -f）</td>
<td><code>docker logs -f my-container</code></td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建镜像（. 表示当前目录）</span></span><br><span class="line">docker build -t my-node-app .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器（-p 映射端口）</span></span><br><span class="line">docker run -d -p 3000:3000 --name my-container my-node-app</span><br><span class="line"><span class="comment"># -d = --detach后台运行 不会占用当前终端。</span></span><br><span class="line"><span class="comment"># -p端口映射 外部访问端口:容器内部监听端口</span></span><br><span class="line"></span><br><span class="line">docker ps <span class="comment"># 查看容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器日志</span></span><br><span class="line">docker logs -f my-container</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it my-container bash <span class="comment"># 进入正在运行的容器</span></span><br><span class="line"><span class="comment">#bash表示启动终端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop my-container</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> my-container</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件挂载 本地开发</span></span><br><span class="line">docker run -v 本地路径:容器路径 ...</span><br><span class="line">docker run -v $(<span class="built_in">pwd</span>):/app -p 3000:3000 my-app</span><br><span class="line"><span class="comment"># -v --volume 把当前目录映射到容器中的 /app</span></span><br><span class="line"><span class="comment">#-v 本地路径:容器内部路径：改动本地文件，容器中实时生效</span></span><br></pre></td></tr></table></figure>
<p>挂载的作用：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>不挂载</th>
<th>挂载</th>
</tr>
</thead>
<tbody><tr>
<td>改代码</td>
<td>要重建镜像</td>
<td>实时生效</td>
</tr>
<tr>
<td>容器删了数据</td>
<td>消失</td>
<td>本地还在</td>
</tr>
<tr>
<td>配置文件注入</td>
<td>要复制进镜像</td>
<td>一挂就行</td>
</tr>
</tbody></table>
<h1 id="dockerignore编写"><a href="#dockerignore编写" class="headerlink" title=".dockerignore编写"></a>.dockerignore编写</h1><p>Docker 构建镜像时用来 忽略不需要包含进镜像的文件或目录的配置文件，功能类似于 .gitignore。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.git/</span></span><br><span class="line">build/</span><br><span class="line">node_modules/</span><br><span class="line">dist</span><br><span class="line"><span class="string">.gitignore</span></span><br><span class="line">Dockerfile</span><br><span class="line">*<span class="string">.log</span></span><br><span class="line"><span class="string">.env</span> <span class="comment">#配置文件避免泄漏</span></span><br></pre></td></tr></table></figure>
<h1 id="使用docker部署tomcat"><a href="#使用docker部署tomcat" class="headerlink" title="使用docker部署tomcat"></a>使用docker部署tomcat</h1><ol>
<li>先到国内镜像市场去搜索对应的tomcat镜像版本</li>
<li>拉取镜像：<br><img src="/images/docker%E4%B8%80%E6%9C%AC%E9%80%9A.assets/e9d578ad0dcb46739594fb61a785af89.png" alt="在这里插入图片描述"><br>docker pull  复制拉取的命令</li>
<li>查看拉取镜像<br>docker images<br><img src="/images/docker%E4%B8%80%E6%9C%AC%E9%80%9A.assets/bb4bd86d45c94dd19d926a43833c6bbf.png" alt="在这里插入图片描述"></li>
<li>创建并启动容器<br><code>docker run --name 容器名 -p 宿主机端口:容器端口  -d  镜像名:标签</code><br>如：<code>docker run --name tomcat-8.0  -p 8081:8080  -d    镜像名:tag</code><br>–name ：指定容器名<br>-p ： 映射端口号，宿主机端口：容器端口<br>-d ：将进程置于后台执行<br>-it：前台运⾏交互模式<br>-v ：挂载外部⽬录， 语法： -v 主机⽬录:容器⽬录<br>-e : 设置环境变量， 语法： -e 变量名&#x3D;值</li>
<li>查看Tomcat容器是否启动<br>输入：docker ps<br><img src="/images/docker%E4%B8%80%E6%9C%AC%E9%80%9A.assets/e618716ce7ad4051a66dd08af15abd4f.png" alt="在这里插入图片描述"><br>-a :如果不加-a，只能看到运⾏成功容器，加了-a可以到所有的容器</li>
<li>在浏览器输入宿主机IP+映射端口，访问验证<br>如果不能访问，则查看防火墙状态，关闭防火墙再次确认<br><img src="/images/docker%E4%B8%80%E6%9C%AC%E9%80%9A.assets/df6c3604e9794331b14b64211c504a80.png" alt="在这里插入图片描述"><br>打开浏览器，输入：宿主机IP:宿主机映射端口，按回车确认能否打开tomcat首页<br><img src="/images/docker%E4%B8%80%E6%9C%AC%E9%80%9A.assets/4a4e2f34fb5a44b980e9702993cd5be6.png" alt="在这里插入图片描述"></li>
</ol>
<h1 id="使用docker部署mysql"><a href="#使用docker部署mysql" class="headerlink" title="使用docker部署mysql"></a>使用docker部署mysql</h1><ol>
<li>到镜像市场搜索mysql指定版本的镜像（5.6）</li>
<li>拉取镜像<br>使用：docker pull  镜像拉取文件<br><img src="/images/docker%E4%B8%80%E6%9C%AC%E9%80%9A.assets/147220dc47d8452d976234a9c64714d6.png" alt="在这里插入图片描述"></li>
<li>创建并启动容器<br><code>docker run --name 容器名  -p 宿主机端口:容器端口  -e MYSQL_ROOT_PASSWORD=密码   -d   镜像名:标签</code><br>如：<code>docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d daocloud.io/mysql:tag</code><br>注：如果端口冲突，怎么解决？<br>查看端口是否冲突：<code>netstat  -tunlp[-anp]| grep 端口</code><br><img src="/images/docker%E4%B8%80%E6%9C%AC%E9%80%9A.assets/fdb72ed8b9fe404d81f415e6bd257500.png" alt="在这里插入图片描述"><br>解决办法：<br>1.kill -9  进程ID     杀死进程<br>2.主动关闭该服务   systemctl  stop   服务名<br>3.在映射端口的时候避免跟该端口重复</li>
</ol>
<h1 id="docker-desktop"><a href="#docker-desktop" class="headerlink" title="docker desktop"></a>docker desktop</h1><p>安装这个也会自动带上终端</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<ul>
<li>apple silicon模拟windows系统 下载dockurr&#x2F;windows镜像<br><code>docker pull --platform=linux/amd64 dockurr/windows                           </code></li>
</ul>
<h1 id="docker运行react的部署"><a href="#docker运行react的部署" class="headerlink" title="docker运行react的部署"></a>docker运行react的部署</h1><p>项目记得构建好，<code>npm run build</code>会生成 dist&#x2F;（Vue）或 build&#x2F;（React）目录。<br>my-project&#x2F;<br>├── build&#x2F;          ← React 打包后目录<br>└── nginx&#x2F;<br>    └── default.conf 本地创建 nginx&#x2F;default.conf 文件，让 Nginx 更好服务打包页面。<br>① 在本地这里创建 Nginx 配置文件 nginx&#x2F;default.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    index index.html;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">        <span class="comment">#try_files ... /index.html 是为了支持前端路由（Vue Router / React Router）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② 运行 Nginx 容器，挂载打包目录和配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name my-nginx \</span><br><span class="line">  -p 8080:80 \</span><br><span class="line">  -v $(<span class="built_in">pwd</span>)/build:/usr/share/nginx/html \</span><br><span class="line">  -v $(<span class="built_in">pwd</span>)/nginx/default.conf:/etc/nginx/conf.d/default.conf \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure>
<ol>
<li>拉取nginx镜像<br><code>docker pull nginx</code></li>
<li>检查是否拉取成功<br><code>docker images</code></li>
<li>创建并启动一个nginx容器<br><code>docker run --name reactweb -p 8088:80 -d nginx</code><br>–name:给新创建的容器命名，此处为：reactweb<br>-p:端口映射，把主机的8088端口映射到容器的80端口，即最后访问localhost:8088<br>-d:成功启动后，输出完整的容器ID<br>nginx :镜像名称<br>此时可以测试localhost:8088访问是否出现nginx<br>3.1 进入容器内部<br><code>docker exec -it reactweb sh</code>这条命令的作用是进入名为 reactweb 的 Docker 容器，并在其中以交互方式启动一个 sh（shell）终端。</li>
<li>将本地文件复制到docker镜像中<br><code>docker cp 本地地址 容器id:nginx映射地址</code><br>本地地址：&#x2F;Application&#x2F;code&#x2F;build<br>容器id:<code>docker ps -a</code> 查看<br>nginx映射地址：进入容器内部后在&#x2F;etc&#x2F;nginx&#x2F;conf.d中default.conf查看，默认是usr&#x2F;share&#x2F;nginx&#x2F;html</li>
<li>如果需要修改nginx的conf</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/conf.d</span><br><span class="line">vim default.conf</span><br><span class="line">nginx -s reload <span class="comment">#编辑完保存后 重启nginx</span></span><br></pre></td></tr></table></figure>
<h1 id="如何挂载本地代码目录来热更新（适合开发阶段）"><a href="#如何挂载本地代码目录来热更新（适合开发阶段）" class="headerlink" title="如何挂载本地代码目录来热更新（适合开发阶段）"></a>如何挂载本地代码目录来热更新（适合开发阶段）</h1><p>开发时用 -v 本地目录:容器目录 把代码挂进去，再用 nodemon 或 vite 监听代码变化自动重启。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#目录结构</span></span><br><span class="line">my-app/</span><br><span class="line">├── app.js</span><br><span class="line">├── package.json</span><br><span class="line">└── Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;nodemon app.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;express&quot;</span>: <span class="string">&quot;^4.18.2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;nodemon&quot;</span>: <span class="string">&quot;^2.0.22&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Dockerfile 专为开发准备，不复制代码进去</span></span><br><span class="line">FROM node:18</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖（只复制 package.json）</span></span><br><span class="line">COPY package*.json ./</span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：代码不 COPY，因为要用挂载实时同步</span></span><br><span class="line">CMD [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;dev&quot;</span>]</span><br><span class="line"></span><br><span class="line">docker build -t my-dev-app .</span><br><span class="line"></span><br><span class="line"><span class="comment">#nodejs项目</span></span><br><span class="line">docker run -d \</span><br><span class="line">  -p 3000:3000 \</span><br><span class="line">  -v $(<span class="built_in">pwd</span>):/app \                <span class="comment"># 本地代码 → 容器</span></span><br><span class="line">  -v /app/node_modules \   <span class="comment">#空挂载，防止本地 node_modules覆盖容器里依赖（这是开发中常见坑）</span></span><br><span class="line">  <span class="comment">#后挂的优先生效</span></span><br><span class="line">  --name dev-app \</span><br><span class="line">  my-dev-app</span><br><span class="line">  </span><br><span class="line"><span class="comment"># vue react项目</span></span><br><span class="line">docker run -d \</span><br><span class="line">  -p 5173:5173 \</span><br><span class="line">  -v $(<span class="built_in">pwd</span>):/app \</span><br><span class="line">  -v /app/node_modules \  <span class="comment">#空挂载 屏蔽掉之前挂载目录对这个路径的覆盖。</span></span><br><span class="line"><span class="comment">#如果只有-v $(pwd):/app 就会把本地node_modules 也挂进去，把容器里运行依赖的 express 等包全部覆盖掉！</span></span><br><span class="line">  --name vite-app \</span><br><span class="line">  node:18 \</span><br><span class="line">  sh -c <span class="string">&quot;cd /app &amp;&amp; npm install &amp;&amp; npm run dev&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="如何部署-Vue-Vite-构建后的静态网页"><a href="#如何部署-Vue-Vite-构建后的静态网页" class="headerlink" title="如何部署 Vue&#x2F;Vite 构建后的静态网页"></a>如何部署 Vue&#x2F;Vite 构建后的静态网页</h1><p>用 vite build 构建出静态文件 → 用 Nginx 或 Node.js 静态服务&#x2F;docker 托管即可</p>
<ul>
<li>nginx</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line"><span class="comment">#windows .zip</span></span><br><span class="line"><span class="comment">#mac homebrew</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#常用 Nginx 命令 (通过 Homebrew):</span></span><br><span class="line">启动 Nginx： brew services start nginx</span><br><span class="line">停止 Nginx： brew services stop nginx</span><br><span class="line">重启 Nginx： brew services restart nginx</span><br><span class="line">重新加载 Nginx 配置（不中断服务）： brew services reload nginx</span><br><span class="line">查看 Nginx 服务状态： brew services info nginx</span><br><span class="line">检查 Nginx 配置文件的语法： nginx -t</span><br><span class="line">Nginx 配置文件位置： 默认/usr/local/etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改nginx配置</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;# 一般8080就够</span><br><span class="line">  server_name localhost;</span><br><span class="line"></span><br><span class="line">  root /path/to/your-project/dist;  <span class="comment"># 这里写你的 dist 路径</span></span><br><span class="line">  index index.html;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;#为支持前端路由（SPA）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># docker+nginx</span></span><br><span class="line"><span class="comment">#把 dist 文件夹打包成 Docker 镜像，部署到服务器</span></span><br><span class="line"><span class="comment"># Dockerfile</span></span><br><span class="line"><span class="comment"># 使用官方 Nginx 镜像</span></span><br><span class="line">FROM nginx:stable-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制构建产物到 nginx 默认目录</span></span><br><span class="line">COPY dist /usr/share/nginx/html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：自定义 nginx 配置支持 SPA 路由</span></span><br><span class="line">COPY nginx.conf /etc/nginx/conf.d/default.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># nginx.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line"></span><br><span class="line">  root /usr/share/nginx/html;</span><br><span class="line">  index index.html;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line"><span class="comment">#部署 Vue、React等前端 SPA（单页面应用）时必须写，不然前端路由刷新会 404！</span></span><br><span class="line"><span class="comment">#如果请求路径在服务器上找不到对应文件或目录，就返回 index.html 给前端，让前端路由来处理这个路径。</span></span><br><span class="line"><span class="comment"># 前端路由只有一个真正的index.html 其他页面都是通过JS前端路由切换的 实际访问的还是index.html</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#构建镜像</span></span><br><span class="line">docker build -t vue-app .</span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker run -d -p 80:80 --name vue-web vue-app</span><br></pre></td></tr></table></figure>
<h1 id="如何组合-Docker-Nginx-实现前后端部署"><a href="#如何组合-Docker-Nginx-实现前后端部署" class="headerlink" title="如何组合 Docker + Nginx 实现前后端部署"></a>如何组合 Docker + Nginx 实现前后端部署</h1><p>使用 Docker 分别部署前端（Vue&#x2F;Vite）+ 后端（Node&#x2F;Express），由 Nginx 统一反向代理 实现域名统一 + 接口转发。<br>跨域问题	不存在，因为前后端统一由 Nginx 托管，不跨域</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------+</span><br><span class="line">|          Nginx             |</span><br><span class="line">|  /api → 后端容器 (3000端口) |</span><br><span class="line">|  /    → 前端容器 (80端口)    |</span><br><span class="line">+-------------▲---------------+</span><br><span class="line">              |</span><br><span class="line">     +--------+---------+</span><br><span class="line">     |                  |</span><br><span class="line">[Node.js容器]       [前端容器]</span><br><span class="line">(端口: 3000)        (端口: 80)</span><br><span class="line"></span><br><span class="line">project-root/</span><br><span class="line">├── backend/        <span class="comment"># Node.js 项目</span></span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   └── app.js</span><br><span class="line">├── frontend/       <span class="comment"># Vue/Vite 项目</span></span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   └── dist/       <span class="comment"># 构建后静态文件</span></span><br><span class="line">├── nginx/</span><br><span class="line">│   ├── default.conf  <span class="comment"># Nginx 配置文件</span></span><br><span class="line"><span class="comment">#如果有数据库 再多个database/文件夹</span></span><br><span class="line">├── docker-compose.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># frontend/Dockerfile</span></span><br><span class="line">FROM nginx:stable-alpine</span><br><span class="line">COPY dist/ /usr/share/nginx/html/</span><br><span class="line">COPY ../nginx/default.conf /etc/nginx/conf.d/default.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#backend/Dockerfile</span></span><br><span class="line">FROM node:18</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY . .</span><br><span class="line">RUN npm install</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;app.js&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># nginx/default.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    index index.html;</span><br><span class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /api/ &#123;</span><br><span class="line">    proxy_pass http://backend:3000/; <span class="comment"># 注意：容器名作为域名 反向代理 转发路径</span></span><br><span class="line">    proxy_http_version 1.1;# HTTP/1.1 协议</span><br><span class="line">    <span class="comment">#专门为 WebSocket 或 HTTP 长连接服务准备</span></span><br><span class="line">    proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;#告诉后端：“我想升级协议”</span><br><span class="line">    proxy_set_header Connection <span class="string">&#x27;upgrade&#x27;</span>;#表示这次请求中开启了 upgrade（例如升级为 WebSocket）</span><br><span class="line">    proxy_set_header Host <span class="variable">$host</span>;#把原始客户端请求的 Host 头转发给后端</span><br><span class="line"><span class="comment">#比如客户端访问的是 example.com 默认 Nginx 发给后端时会把 Host 改成 backend</span></span><br><span class="line">    proxy_cache_bypass <span class="variable">$http_upgrade</span>;#如果请求是 Upgrade（例如 WebSocket）跳过缓存。</span><br><span class="line"><span class="comment">#避免缓存对长连接、实时性要求高的服务产生影响</span></span><br><span class="line"><span class="comment">#虽然可能没有设置 Nginx 缓存，但加上这行是种“保险”</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#docker-compose.yml</span></span><br><span class="line"><span class="comment">#定义和一键启动多个 Docker 容器的配置文件</span></span><br><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  backend:</span><br><span class="line">    build: ./backend</span><br><span class="line">    container_name: backend</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line"></span><br><span class="line">  frontend:</span><br><span class="line">    build: ./frontend</span><br><span class="line">    container_name: frontend</span><br><span class="line">    depends_on:</span><br><span class="line">      - backend</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;80:80&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加上数据库</span></span><br><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  frontend:</span><br><span class="line">    build: ./frontend</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    depends_on:#容器启动顺序依赖 backend先启动</span><br><span class="line">      - backend</span><br><span class="line"></span><br><span class="line">  backend:</span><br><span class="line">    build: ./backend</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: mongo</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;27017:27017&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - mongo-data:/data/db</span><br><span class="line"></span><br><span class="line">volumes:# 挂载数据卷（持久化容器数据）</span><br><span class="line"><span class="comment">#让 MongoDB 的数据存在宿主机的 volume 里（本地文件系统），即使容器删除也不会丢数据</span></span><br><span class="line">  mongo-data:</span><br><span class="line"></span><br><span class="line">docker-compose up --build <span class="comment">#启动</span></span><br><span class="line"><span class="comment"># 前端页面：http://localhost/</span></span><br><span class="line"><span class="comment"># API 请求（如 Vue axios 发起）：http://localhost/api/user</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义volumes数据卷的方式有两种，最推荐的就是在docker-compose.yml定义，Docker Compose 在你第一次运行 docker compose up 命令时，会自动为你创建这个命名卷（如果它不存在的话）。<br>查看卷列表： docker volume ls<br>查找卷的实际路径： docker volume inspect &lt;卷名称&gt;，然后查看 “Mountpoint” 字段。<br>但不推荐直接手动修改或删除这个路径下的文件</li>
<li>公司常用生产部署流程<br>用 CI&#x2F;CD 平台 + Docker 容器化 + Nginx 网关 + Kubernetes 或 Docker Compose 管理多服务 + 云服务器（或 K8s 集群）部署。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                     +-------------------+</span><br><span class="line">                     |    用户浏览器      |</span><br><span class="line">                     +--------+----------+</span><br><span class="line">                              |</span><br><span class="line">                              v</span><br><span class="line">                     +--------+----------+</span><br><span class="line">                     |     Nginx 网关     | ← 域名、TLS、代理路由</span><br><span class="line">                     +--------+----------+</span><br><span class="line">                              |</span><br><span class="line">        +---------------------+----------------------+</span><br><span class="line">        |                                            |</span><br><span class="line">        v                                            v</span><br><span class="line">+---------------+                            +---------------+</span><br><span class="line">|  前端容器      |                            |   后端容器     |</span><br><span class="line">|  Vue / React   |                            | Node / NestJS |</span><br><span class="line">|  静态文件服务   |                            | API 接口服务   |</span><br><span class="line">+-------+-------+                            +-------+-------+</span><br><span class="line">        |                                            |</span><br><span class="line">        v                                            v</span><br><span class="line">+---------------+                            +---------------+</span><br><span class="line">| CDN（选配）    |                            | 数据库容器     |</span><br><span class="line">| OSS / COS      |                            | MySQL / Mongo  |</span><br><span class="line">+---------------+                            +---------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>CI&#x2F;CD 自动化流程</li>
</ul>
<table>
<thead>
<tr>
<th>服务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TLS &#x2F; HTTPS</td>
<td>Let’s Encrypt 自动签发证书</td>
</tr>
<tr>
<td>域名解析</td>
<td>Cloudflare &#x2F; 阿里云 DNS</td>
</tr>
<tr>
<td>CDN 加速</td>
<td>前端静态资源用 CDN</td>
</tr>
<tr>
<td>日志采集</td>
<td>Loki &#x2F; ELK &#x2F; 阿里 SLS</td>
</tr>
<tr>
<td>监控告警</td>
<td>Prometheus + Grafana &#x2F; 阿里 ARMS</td>
</tr>
<tr>
<td>自动缩容</td>
<td>K8s 自动伸缩（HPA）</td>
</tr>
</tbody></table>
<p>常用平台：<br>GitHub Actions<br>GitLab CI<br>Jenkins（传统）<br>阿里云 CodePipeline、腾讯云 DevOps、Coding 等</p>
<p>流程：<br>push 代码 →<br>CI 流程：<br>安装依赖<br>运行测试<br>构建镜像<br>推送到镜像仓库（如阿里云 ACR &#x2F; Docker Hub）<br>CD 流程：<br>拉取镜像<br>部署到服务器 &#x2F; K8s 集群</p>
<h1 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h1><ol>
<li>复制本地文件（夹）报错<br>检查命名，不要有特殊字符<br>电脑设备开启docker文档磁盘访问权限<br>Mac-m芯片选择nginx-arm64且没显示不支持图标的<br><img src="/images/docker%E4%B8%80%E6%9C%AC%E9%80%9A.assets/4ff69a8e5f464760b76bbf6c305a806e.png" alt="在这里插入图片描述"><br>点执行创建容器，其他地方都可以随意，唯独80tcp对应的port要填8080<br><img src="/images/docker%E4%B8%80%E6%9C%AC%E9%80%9A.assets/20ab6cf2e4ef4936b551bde029ca50f5.png" alt="在这里插入图片描述"><br>访问<a href="http://localhost:8080，可以看到欢迎页面">http://localhost:8080，可以看到欢迎页面</a></li>
</ol>

            </div>
        </div>
    </article>

    
    
<nav class="article-nav">
  
    <a href="/2025/07/15/nodejs%E4%B8%80%E6%9C%AC%E9%80%9A/" id="article-nav-newer" class="article-nav-link-wrap prev">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          nodejs一本通
        
      </div>
    </a>
  
  
    <a href="/2025/07/12/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" id="article-nav-older" class="article-nav-link-wrap next">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">包管理工具</div>
    </a>
  
</nav>

    

    
</div>
    </div>
    <footer class="site-footer">
        <div class="global-width">
            <ul class="site-widget">
                
                <li class="widget widget-tag">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/English/" rel="tag">English</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/basics/" rel="tag">basics</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/frontend/" rel="tag">frontend</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/projects/" rel="tag">projects</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tags/" rel="tag">tags</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

                </li>
                
                <li class="widget widget-category">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/daily-report/">daily_report</a><span class="category-list-count">52</span></li></ul>
    </div>
  </div>

                </li>
                
                <li class="widget widget-recent_posts">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-body">
      <ul>
        
          <li>
            <a href="/2025/07/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a>
          </li>
        
          <li>
            <a href="/2025/07/20/%E6%87%92%E5%8A%A0%E8%BD%BD%E9%A2%84%E5%8A%A0%E8%BD%BD/">懒加载预加载</a>
          </li>
        
          <li>
            <a href="/2025/07/20/PWA/">PWA</a>
          </li>
        
          <li>
            <a href="/2025/07/16/nodejs%E6%A8%A1%E5%9D%97%E5%A4%A7%E5%85%A8/">nodejs模块大全</a>
          </li>
        
          <li>
            <a href="/2025/07/15/nodejs%E4%B8%80%E6%9C%AC%E9%80%9A/">nodejs一本通</a>
          </li>
        
      </ul>
    </div>
  </div>

                </li>
                
            </ul>
        </div>
        <div class="site-info">
            <address>
                &copy; 2014 <a href="https://70v-yoyo.github.io">Yoyo&#39;s blog</a> All Right Reserved. <br/>
                Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a>. Theme by <a target="_blank" rel="noopener" href="http://zzoman.com">ZZOMAN</a>
                <p><a target="_blank" href="https://github.com/70v-Yoyo">My github</a></p>
            </address>
        </div>
    </footer> 
    
    
    <script src="/libs/jquery-1.11.3.min.js" type="text/javascript"></script>
    
    <script src="/libs/fancybox/jquery.fancybox.js" type="text/javascript"></script>
    
    <script src="/js/site_init.js" type="text/javascript"></script>
     
    <noscript>
        <style>
            article {
                position: absolute;
                width: 0;
                height: 0;
                overflow: hidden;
                opacity: 0;
            }

        </style>
        <h1>JS已被禁用</h1>
    </noscript>
<!-- hexo injector body_end start -->
    <script>
      (function() {
        function moveElementIfSmallScreen() {
          const toc = document.getElementById('fixed-toc-container');
          const article = document.querySelector("article");
          const toggleBtn = document.getElementById('toggle_btn');
          if (!toc || !article) return;
          if (window.innerWidth < 1024 && article.firstElementChild !== toc) {
            console.log('small screen!!')
            
            article.insertBefore(toc, article.firstChild);//移动节点，而非复制
            
            toggleBtn.style.display='none';
            // 替换样式：取消 fixed，设置适合正文的样式
            toc.style.position = 'relative';
            toc.style.top = '';
            toc.style.left = '';
            toc.style.width = '100%';
            toc.style.maxHeight = 'none';
            toc.style.overflowY = 'visible';
            toc.style.overflowX = 'visible';
            toc.style.padding = '1em';
            toc.style.borderLeft = 'none';
            toc.style.borderBottom = '1px solid #ddd';
            toc.style.background = '#f9f9f9';
            toc.style.opacity = '1';
            toc.style.zIndex = '9999';
            toc.style.boxShadow = 'none';
            toc.style.margin = '1rem';
            toc.style.paddingTop= '2rem';
          }
        }
        window.addEventListener("DOMContentLoaded", moveElementIfSmallScreen);
        window.addEventListener("resize", moveElementIfSmallScreen);
      })();
    </script>
  <!-- hexo injector body_end end -->
    <div id="fixed-toc-container" style="
      position: fixed;
      top: 0vh;
      left: 0px;
      width: 15rem;
      max-height: 80vh;
      overflow-y: auto;
      overflow-x: auto;
      padding: 10px;
      border-left: 2px solid #ccc;
      font-size: 14px;
      line-height: 1.5;
      background: #fff;
      opacity:0.8;
      z-index: 9999;
      box-shadow:
        0 2px 4px rgba(0, 0, 0, 0.05),  /* 第一层：近处柔和 */
        0 8px 16px rgba(0, 0, 0, 0.08); /* 第二层：远处扩散 */
    ">
      <strong>Contents</strong>
      <div id="toggle_btn" style="
      position:absolute;
      right:1rem;
      display:inline-block;
      width:2rem;
      text-align:center;
      border:1px solid #ccc;
      "><</div>
      <ul id="fixed-toc-list" style="list-style: none; padding-left: 10px;"></ul>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const nav = document.querySelector('nav');
        if (nav) {
          const navBottom = nav.getBoundingClientRect().bottom;//浏览器JS API
          console.log('nav bottom:', navBottom);
          // 设置toc元素 top = nav bottom
          const toc = document.querySelector('#fixed-toc-container');
          if (toc) {
            toc.style.top = navBottom + 'px';
            toc.style.maxHeight=window.innerHeight - navBottom.getBoundingClientRect().bottom;
          }
        }
      });

      const myDiv = document.getElementById('toggle_btn');
      var tocList=document.getElementById("fixed-toc-list");
      var tocContainer=document.getElementById("fixed-toc-container");
      function handleClickBtn() {
        console.log('Div 被点击了！');
        if(myDiv.textContent==='<'){
          myDiv.textContent ='>'
          tocList.style.display='none'
          tocContainer.style.width='11rem'
        }else{
          myDiv.textContent ='<'
          tocList.style.display='block'
          tocContainer.style.width='15rem'
        }
          
      }


      myDiv.addEventListener('click', handleClickBtn);// 绑定点击事件


      (function() {
      const Patternstr = "/*\\d{4}/\\d{2}/\\d{2}/.*"; //本身是字符串插入，所以对符号要转义
      //"^//*"->"/"
      //"/.*"->".*"
      //JS引擎中""转义
      //正则表达式引擎也是""转义
      const dataPattern = new RegExp(Patternstr);
      const path = window.location.pathname;
      console.log(dataPattern.toString(),path,dataPattern.test(path));//控制台在渲染时省略了反斜杠的可视表示。
      if (!dataPattern.test(path)&&(path==='/'||path==='index.html')) {
        console.log('no toc')
        let toc = document.getElementById('fixed-toc-container');
        if (toc) toc.style.display = 'none';
        return;
      }
        var content = document.querySelector('body');
        console.log('content',content)
        //var tocList = document.getElementById('fixed-toc-list');
        if (!content || !tocList) {
          document.getElementById('fixed-toc-container').style.display = 'none';
          return;
        }
        var headings = content.querySelectorAll('h1, h2, h3, h4');
        console.log('headings',headings)
        if(headings){
          const h1Element=headings[0];
          const rect = h1Element.getBoundingClientRect();
          if(rect.left<150){
           tocContainer.style.right='0px';
           tocContainer.style.left = 'auto'; // 移除内联的 left 样式
            //不是设置right:0 就替换left:0 需要移除
            console.log('to right')
          }
          console.log(rect.left,'150')
        }
        
        if (headings.length === 0) {
          document.getElementById('fixed-toc-container').style.display = 'none';
          return;
        }
        headings.forEach(function(heading, i) {
          if (!heading.id) {
            heading.id = 'heading-' + i;
          }
        });
        headings.forEach(function(heading) {
          var level = parseInt(heading.tagName.substring(1));
          var li = document.createElement('li');
          li.style.marginLeft = (level - 1) * 15 + 'px';
          var a = document.createElement('a');
          a.href = '#' + heading.id;
          a.textContent = heading.textContent;
          a.style.color = '#555';
          a.style.textDecoration = 'none';
          a.onmouseover = function() { a.style.textDecoration = 'underline'; };
          a.onmouseout = function() { a.style.textDecoration = 'none'; };
          li.appendChild(a);
          tocList.appendChild(li);
        });
      })();
    </script>
  </body>
</html>
