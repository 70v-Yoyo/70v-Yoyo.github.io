<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    
    
    <title>JS一本通 | Yoyo&#39;s blog</title>
    
    <link rel="alternative" href="/atom.xml" title="Yoyo&#39;s blog" type="application/atom+xml">
    
    
<link rel="stylesheet" href="/css/style.css">

    
    <link rel="stylesheet" href="/libs/fancybox/jquery.fancybox.css" charset="utf-8">
    
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
<!-- hexo injector head_end start --><script src="./func.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>
<body class="site">
    <!-- 遮罩层 -->
    <div id="mask-layer">
    </div>
    
    <header class="site-header">
        <h1 class="site-title"><a href="/">Yoyo&#39;s blog</a></h1>
        <nav class="site-nav">
            <ul class="nav">
                
                <li><a href="/">Home</a></li>
                
                <li><a href="/archives">Archives</a></li>
                
                
                <li><a href="/atom.xml" title="RSS Feed">rss</a></li>
                
                <li><a class="toggle-search" href="#search">search</a></li>
            </ul>
        </nav>
        <div class="site-search" id="search">
            <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="https://70v-yoyo.github.io"></form>
        </div>
        
            <div class="site-header-background" style="background-image:url('http://reumia.github.io/hexo-theme-zzoman2015/images/background-zzoman2015.jpg')"></div>
        
    </header>
    <div class="site-body">
        <div class="global-width">
    <article class="article" data-layout="post" data-slug="【前端】JS大全">
        <div class="article-content">
            
            
            <header class="article-header">
                <div class="article-meta">
                    <a href="/2025/07/20/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91JS%E5%A4%A7%E5%85%A8/" class="article-date">
  <time datetime="2025-07-20T12:04:34.000Z">2025-07-20</time>
</a>
                    
                    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/frontend/" rel="tag">frontend</a></li></ul>

                </div>
                
    <h1 class="article-title" itemprop="name">
      <a href="/2025/07/20/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91JS%E5%A4%A7%E5%85%A8/">JS一本通</a>
    </h1>

            </header>
            
            <div class="article-body">
                <meta name="referrer" content="no-referrer" />

<blockquote>
<p>版本：20250720</p>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JavaScript严格区分大小写</p>
<ul>
<li>应用场景<br>表单动态校验（密码强度）<br>网页特效<br>服务端开发 Node.js<br>桌面程序 Electron<br>App<br>控制硬件-物联网 Ruff<br>游戏开发 cocos2d-js</li>
<li>javaScript（JS）包括：<ul>
<li>ECMAScript是JS的语言标准 如ES6</li>
<li>DOM文档对象模型</li>
<li>BOM浏览器对象模型，包含window，location，screen，history..</li>
</ul>
</li>
</ul>
<blockquote>
<p>避免使用eval()&#x2F;with()这种昂贵操作且不安全</p>
</blockquote>
<p>&#x3D;&#x3D;打印&#x3D;&#x3D;</p>
<p>console.log()简写为c()</p>
<p>&#x3D;&#x3D;引入&#x3D;&#x3D;<br>1、内部<br>放入<code>&lt;head&gt;</code><br><code>&lt;script type=&quot;text/javascript&quot;&gt;js code&lt;/script&gt;</code><br>2、外部：js文件引入 (更方便维护）<br><code>&lt;script type=&quot;text/javascript&quot; src=&quot;...&quot;&gt;&lt;/script&gt; </code></p>
<p>&#x3D;&#x3D;运行条件&#x3D;&#x3D;<br>必须先有HTML页面，在HTML页面中引入JavaScript，浏览器加载该HTML页面，执行JavaScript代码。</p>
<p>&#x3D;&#x3D;注释&#x3D;&#x3D; <code>//  /* */</code><br>&#x3D;&#x3D;废弃特性&#x3D;&#x3D;<br>很多类似这种特性都被废除，比如字符串对象，都是不再将被处理的对象作为参数传递，而是用实例其自带的方法调用。</p>
<table>
<thead>
<tr>
<th>❌ 非标准旧写法</th>
<th>✅ 推荐的标准写法</th>
</tr>
</thead>
<tbody><tr>
<td><code>Array.slice(myArr, 0, 2)</code></td>
<td><code>myArr.slice(0, 2)</code></td>
</tr>
<tr>
<td><code>Array.forEach(myArr, fn)</code></td>
<td><code>myArr.forEach(fn)</code></td>
</tr>
<tr>
<td><code>Array.map(myArr, fn)</code></td>
<td><code>myArr.map(fn)</code></td>
</tr>
<tr>
<td><code>Array.filter(myArr, fn)</code></td>
<td><code>myArr.filter(fn)</code></td>
</tr>
<tr>
<td><code>Array.join(myArr, &#39;,&#39;)</code></td>
<td><code>myArr.join(&#39;,&#39;)</code></td>
</tr>
</tbody></table>
<h1 id="JS-核心基础"><a href="#JS-核心基础" class="headerlink" title="JS 核心基础"></a>JS 核心基础</h1><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><ul>
<li>JS是单线程，不能同时进行；因为 JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对<br>某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</li>
<li>同步任务v.s.异步任务<br>为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。故出现了JS中所有任务可以分成两种，<strong>同步任务（synchronous）<strong>和</strong>异步任务（asynchronous）</strong>。<br>同步任务指的是：在主线程【执行栈】上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<br>异步任务指的是：不进入主线程、而进入【任务队列】的任务，当主线程中的任务运行完了，才会从”任务队列”取出异步任务放入主线程执行。<blockquote>
<p>比如你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>【异步任务】类别</th>
<th>示例&#x2F;说明</th>
</tr>
</thead>
<tbody><tr>
<td>网络请求</td>
<td>fetch(), axios.get(), XMLHttpRequest</td>
</tr>
<tr>
<td>定时器任务</td>
<td>setTimeout, setInterval, requestAnimationFrame</td>
</tr>
<tr>
<td>DOM 事件回调</td>
<td>click, keyup, onload 等事件回调</td>
</tr>
<tr>
<td>Promise 任务</td>
<td>.then, .catch, .finally</td>
</tr>
<tr>
<td>Async&#x2F;Await</td>
<td>封装 Promise 的更简洁语法</td>
</tr>
<tr>
<td>微任务（Microtasks）</td>
<td>queueMicrotask, Promise.then</td>
</tr>
<tr>
<td>宏任务（Macrotasks）</td>
<td>setTimeout, setInterval, MessageChannel</td>
</tr>
<tr>
<td>Web Worker</td>
<td>在子线程中处理数据（比如大计算任务）</td>
</tr>
<tr>
<td>事件循环触发</td>
<td>浏览器&#x2F;Node 的 event loop 会安排任务执行顺序</td>
</tr>
</tbody></table>
<h3 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h3><ul>
<li>定义：浏览器HTML5提供多线程技术，允许在主线程之外创建后台线程，使用Web Worker可以将费时的JS任务从主线程中分离出来，让主线程专注于处理UI和用户交互等任务。避免页面卡顿，提升用户体验。</li>
<li>特点：浏览器中的独立线程，运行在主线程之外；不能访问 DOM 和大部分浏览器 API；只能通过消息传递与主线程通信</li>
<li>类型<br>Dedicated Worker（专用工作线程）：一个 Worker 只服务于创建它的页面<br>Shared Worker（共享工作线程）：可以被多个脚本共享（较少用）</li>
<li>使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js 主线程</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;worker.js&#x27;</span>);<span class="comment">//1. 创建实例</span></span><br><span class="line"></span><br><span class="line">worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;开始计算&#x27;</span>);</span><br><span class="line"></span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Worker 返回：&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">worker.<span class="title function_">terminate</span>();<span class="comment">//主线程使用则关闭webWorker</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//worker.js</span></span><br><span class="line"><span class="comment">//onmessage接收主线程消息的事件处理函数 同时监听</span></span><br><span class="line"><span class="comment">//postMessage发送消息给主线程 主线程发送给webWorker都用这个</span></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;<span class="comment">//2. 定义任务</span></span><br><span class="line">  <span class="comment">// 执行耗时任务</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1e7</span>; i++) &#123;</span><br><span class="line">    result += i;</span><br><span class="line">  &#125;</span><br><span class="line">  self.<span class="title function_">postMessage</span>(result); <span class="comment">// 发送结果回主线程</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>与service worker异同</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sw.js</span></span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拦截请求，实现缓存策略</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>共同点：<br>都是浏览器提供的多线程技术<br>都在主线程之外运行，避免阻塞页面的 UI 渲染。<br>都不能直接访问 DOM，出于线程安全和性能考虑，两个 Worker 线程都无法操作页面 DOM。<br>都运行在独立的线程环境，线程独立于主线程，互不干扰，提高性能和响应能力。<br>通信机制基于消息传递，使用 postMessage 进行数据交互（Service Worker 通过事件监听机制间接实现，Web Worker 直接用 postMessage）。<br>都是异步执行，工作线程中的代码不会阻塞主线程，任务执行是异步的。<br>都受浏览器安全限制，都需要在安全上下文中运行（Service Worker 必须在 HTTPS 下，Web Worker 在页面上下文但通常也受安全策略限制）。<br>都是用来提升网页性能和用户体验的技术<br>通过分离主线程任务，避免页面卡顿和提高响应速度。</li>
<li>对比</li>
</ul>
<table>
<thead>
<tr>
<th>方面</th>
<th>Web Worker</th>
<th>Service Worker</th>
</tr>
</thead>
<tbody><tr>
<td><strong>主要作用</strong></td>
<td>多线程运行 JS 代码，处理计算任务</td>
<td>拦截网络请求，实现离线缓存与后台功能</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>页面绑定，页面关闭即终止</td>
<td>独立于页面，可长期存在</td>
</tr>
<tr>
<td><strong>访问 DOM</strong></td>
<td>不可访问</td>
<td>不可访问</td>
</tr>
<tr>
<td><strong>通信方式</strong></td>
<td>主线程与 Worker 通过 <code>postMessage</code> 进行双向通信</td>
<td>事件驱动，监听 <code>fetch</code>、<code>push</code> 等事件</td>
</tr>
<tr>
<td><strong>安全限制</strong></td>
<td>无需 HTTPS（任意页面均可用）</td>
<td>只能在 HTTPS 环境下使用</td>
</tr>
<tr>
<td><strong>主要应用场景</strong></td>
<td>复杂计算、数据处理、图像处理、数据库&#x2F;文件操作</td>
<td>离线缓存、PWA、后台推送、网络代理</td>
</tr>
<tr>
<td><strong>创建方式</strong></td>
<td>通过 <code>new Worker()</code> 创建</td>
<td>通过 <code>navigator.serviceWorker.register()</code> 注册</td>
</tr>
<tr>
<td><strong>线程性质</strong></td>
<td>独立的 JS 线程</td>
<td>独立的后台线程（生命周期更长）</td>
</tr>
<tr>
<td><strong>持久性</strong></td>
<td>页面关闭即销毁</td>
<td>可能长期驻留，独立于任何页面</td>
</tr>
<tr>
<td><strong>网络请求拦截</strong></td>
<td>不支持</td>
<td>支持（可控制页面的请求响应）</td>
</tr>
</tbody></table>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>JavaScript在按代码从前往后顺序执行，依次压入执行栈，每次执行一个方法，都会为它生成独有的执行环境（上下文)，当这个方法执行完成后，就会销毁当前的执行环境，并从栈中弹出此方法，然后继续执行下一个方法。执行栈是栈，先进后出，但并不是代码从后往前执行，而是调用一个压栈、它执行完出栈，所以还是从前往后执行。<br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/fc52f2ed526b44958e547ec167f55bd1.png" alt="在这里插入图片描述"><br>任务队列分为宏任务、微任务两种队列。<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41775119/article/details/147123962?fromshare=blogdetail&sharetype=blogdetail&sharerId=147123962&sharerefer=PC&sharesource=qq_41775119&sharefrom=from_link">详见事件循环专题 点击跳转</a><br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/5b5d6784e3c84b1ab87cbe5de25ab283.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面三个片段的输出各是什么</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//1-&gt;2-&gt;3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//将回调函数放入 宏任务队列，虽然 0ms 但仍然要等主线程任务执行完毕后才执行。</span></span><br><span class="line"><span class="comment">//即使 setTimeout 的时间是 0ms，它依然不会立即执行，而是等 同步任务执行完毕 才执行。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//1-&gt;2-&gt;3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"><span class="comment">//1 2 3（如果 3 秒不点击） </span></span><br><span class="line"><span class="comment">// 1 2 click 3（如果 3 秒内点击）</span></span><br></pre></td></tr></table></figure>
<h2 id="变量-作用域"><a href="#变量-作用域" class="headerlink" title="变量&#x2F;作用域"></a>变量&#x2F;作用域</h2><ul>
<li>声明变量方式对比</li>
</ul>
<table>
<thead>
<tr>
<th>关键词</th>
<th>可重复声明</th>
<th>可重新赋值</th>
<th>块级作用域</th>
<th>是否提升（hoist）</th>
</tr>
</thead>
<tbody><tr>
<td><code>var</code></td>
<td>是</td>
<td>是</td>
<td>❌ 无（函数作用域）</td>
<td>是（值为 <code>undefined</code>）</td>
</tr>
<tr>
<td><code>let</code></td>
<td>❌ 否</td>
<td>是</td>
<td>是</td>
<td>❌ 不会提升</td>
</tr>
<tr>
<td><code>const</code></td>
<td>❌ 否</td>
<td>❌ 否（值不能改）</td>
<td>是</td>
<td>❌ 不会提升</td>
</tr>
</tbody></table>
<ul>
<li>TDZ Temporal Dead Zone（暂时性死区）<br>定义：在变量 let &#x2F; const 声明之前的区域内访问它，会抛出错误</li>
<li>作用域对比</li>
</ul>
<table>
<thead>
<tr>
<th>对比项</th>
<th>函数作用域 (<code>var</code>)</th>
<th>块级作用域 (<code>let/const</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>是否提升</td>
<td>提升，值为 undefined</td>
<td>❌ 不提升，TDZ 阻止访问</td>
</tr>
<tr>
<td>作用范围</td>
<td>整个函数内</td>
<td>仅限当前 <code>&#123;&#125;</code> 内</td>
</tr>
<tr>
<td>重复声明</td>
<td>允许（不推荐）</td>
<td>❌ 不允许</td>
</tr>
<tr>
<td>是否存在 TDZ</td>
<td>❌ 不存在</td>
<td>存在</td>
</tr>
<tr>
<td>常用于</td>
<td>老代码（兼容性）</td>
<td>推荐日常开发全部用 <code>let/const</code></td>
</tr>
</tbody></table>
<p>作用域还可分为局部、全局<br>只要是代码至少有一个作用域，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；</p>
<ul>
<li>全局污染<br>引入的js文件中存在名字相同的情况，只会选择其一，后覆盖前。</li>
</ul>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><ul>
<li>执行上下文：包括变量环境、作用域链、this 绑定</li>
<li>定义：嵌套关系的作用域串联起来形成作用域链。</li>
<li>作用：在内部函数可以访问外部函数变量，用链式查找决定哪些数据能被内部函数访问。<br>【就近原则】本质是底层变量查找机制，优先当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域。<br>子作用域能够访问父作用域，父级作用域无法访问子级作用域</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( num );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">456</span>;</span><br><span class="line"><span class="title function_">f1</span>();</span><br></pre></td></tr></table></figure>
<p><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/90cd966fb1314e36ba1e4133a4b1f688.png" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">&#x27;22&#x27;</span>;</span><br><span class="line">    <span class="title function_">fn2</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="title function_">fn3</span>();</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//a的值 ?</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//b的值 ?</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br></pre></td></tr></table></figure>
<p><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/b3d9b9ed072e41cb8dd8b631fdbd187c.png" alt="在这里插入图片描述"></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript 是一种弱类型&#x2F;动态语言。不用提前声明变量类型，在程序运行过程中，类型会被自动确定。</p>
<ul>
<li>变量类型 7+1</li>
<li><ul>
<li>基本数据类型：变量存储的是值本身<br>Number&#x2F;String&#x2F;Boolean&#x2F;Undefined&#x2F;Null&#x2F;Symbol&#x2F;Bigint</li>
</ul>
</li>
<li><ul>
<li>引用数据类型：变量存储的仅是地址（引用），通过 new 关键字创建的对象<br>Object（如Array&#x2F;Function&#x2F;Date等）</li>
</ul>
</li>
<li>NAN<br>NaN（Not a Number，非数）表示未定义或不可表示的值。常在浮点数运算使用。<code>Number(&quot;123nb&quot;)</code>会报错。它是全局属性，属于 Number 类型，数学运算错误\类型转换失败会得到。<br><strong>NaN这个特殊的Number与所有其他值都不相等，包括它自己：</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="comment">//唯一能判断NaN的方法是通过isNaN()函数： true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//isNaN()用来判断一个变量是否为非数字的类型，不是数字返回true，是数字返回false</span></span><br><span class="line">bool_num=<span class="built_in">isNaN</span>(num)</span><br></pre></td></tr></table></figure>
<ul>
<li>null v.s. undefined<br>null表示“空”值，和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。<br>undefined，是只声明但未赋值变量的默认值。<br>未声明过的值调用会报错，ReferenceError: myVar is not defined</li>
<li>不声明的全局变量 以及 strict模式<br>未声明的变量自动为全局变量。<br>ECMA推出strict模式：未申明变量就使用将导致运行错误<br>启用strict方法是在JavaScript代码第一行写上：’use strict’;<br>不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;myy&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> name);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">value=<span class="title function_">prompt</span>(text,defaultText)<span class="comment">//用于显示可提示用户进行输入的对话框。</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(x)<span class="comment">//写在页面上</span></span><br><span class="line"><span class="keyword">var</span> htmlStr=<span class="string">&#x27;&lt;h1&gt;&#x27;</span>+x+<span class="string">&#x27;&lt;/h1&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//undefine null NAN</span></span><br><span class="line">		<span class="keyword">var</span> str;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">        <span class="keyword">var</span> variable = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(variable + <span class="string">&#x27;pink&#x27;</span>); <span class="comment">// undefinedpink</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(variable + <span class="number">1</span>); <span class="comment">// NaN  undefined 和数字相加 最后的结果是 NaN</span></span><br><span class="line">        <span class="comment">// null 空值</span></span><br><span class="line">        <span class="keyword">var</span> space = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(space + <span class="string">&#x27;pink&#x27;</span>); <span class="comment">// nullpink</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(space + <span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//几进制</span></span><br><span class="line">num=<span class="number">0b1</span>;</span><br><span class="line">num=<span class="number">0o5</span>;</span><br><span class="line">num=<span class="number">0xa</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显式变量转换</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="title class_">Number</span>(<span class="string">&quot;23&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> age = <span class="built_in">parseInt</span>(<span class="title function_">prompt</span>(<span class="string">&#x27;请输入年龄:&#x27;</span>));</span><br><span class="line"><span class="keyword">var</span> height = <span class="built_in">parseFloat</span>(<span class="title function_">prompt</span>(<span class="string">&#x27;请输入身高(m):&#x27;</span>));</span><br><span class="line"><span class="keyword">var</span> str=num.<span class="title function_">toString</span>();<span class="comment">//或String(num)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//支持隐式转换</span></span><br><span class="line"><span class="keyword">var</span> num=num+<span class="string">&quot;string&quot;</span>;<span class="comment">//数字自动转换为字符串</span></span><br><span class="line">num=<span class="string">&#x27;12&#x27;</span>-<span class="number">2</span>;<span class="comment">//见到- * / 转成数字再运算</span></span><br></pre></td></tr></table></figure>
<p>变量最后如果在全局作用域中也没有找到，则报ReferenceError错误<br>这与使用 var 声明的变量不同，var 声明的变量可挂载在全局对象上，因此可以通过 window.variableName 的方式访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们每次直接调用的alert()函数其实也是window的一个变量。</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&#x27;调用window.alert()&#x27;</span>);</span><br><span class="line"><span class="comment">// 给alert赋一个新函数:</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">alert</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>); <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Number</span>.<span class="property">MIN_VALUE</span>); <span class="comment">// 5e-324</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Infinity</span> ，代表无穷大，大于任何数值</span><br><span class="line">-<span class="title class_">Infinity</span> ，代表无穷小，小于任何数值</span><br><span class="line"><span class="title class_">NaN</span> ，<span class="title class_">Not</span> a number，代表一个非数值</span><br></pre></td></tr></table></figure>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><ul>
<li>typeof 只能判断基础类型 + 函数，不能判断数组&#x2F;对象&#x2F;null 的区别（它们全是 object）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> []       <span class="comment">// 👉 &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>     <span class="comment">// 👉 &#x27;object&#x27; ⚠️（历史 bug）</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;       <span class="comment">// 👉 &#x27;object&#x27;</span></span><br><span class="line"><span class="title function_">typeof</span> (<span class="function">() =&gt;</span> &#123;&#125;) <span class="comment">// 👉 &#x27;function&#x27;</span></span><br><span class="line"></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span>       <span class="comment">// ✅ true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>      <span class="comment">// ✅ true</span></span><br><span class="line">(<span class="function">() =&gt;</span> &#123;&#125;) <span class="keyword">instanceof</span> <span class="title class_">Function</span> <span class="comment">// ✅ true</span></span><br><span class="line"><span class="number">123</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>     <span class="comment">// ❌ false（原始类型不是对象）</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>) <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">// ✅ true</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>    <span class="comment">// ❌ false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取更准确的类型判断。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">123</span>)         <span class="comment">// &#x27;[object Number]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;abc&#x27;</span>)       <span class="comment">// &#x27;[object String]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>)        <span class="comment">// &#x27;[object Null]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>)   <span class="comment">// &#x27;[object Undefined]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])          <span class="comment">// &#x27;[object Array]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)          <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="function">() =&gt;</span> &#123;&#125;)    <span class="comment">// &#x27;[object Function]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())  <span class="comment">// &#x27;[object Date]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/\d+/</span>)       <span class="comment">// &#x27;[object RegExp]&#x27;</span></span><br><span class="line"></span><br><span class="line">(<span class="number">123</span>).<span class="property">constructor</span> === <span class="title class_">Number</span>     <span class="comment">//  true</span></span><br><span class="line">(<span class="string">&#x27;abc&#x27;</span>).<span class="property">constructor</span> === <span class="title class_">String</span>   <span class="comment">//  true</span></span><br><span class="line">(&#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Object</span>      <span class="comment">//  true</span></span><br><span class="line">([]).<span class="property">constructor</span> === <span class="title class_">Array</span>       <span class="comment">//  true</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法</th>
<th>能判断的类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><code>typeof</code></td>
<td>基本类型 + 函数</td>
<td>简单快捷</td>
<td>无法区分对象&#x2F;数组&#x2F;null</td>
</tr>
<tr>
<td><code>instanceof</code></td>
<td>引用类型（对象&#x2F;数组等）</td>
<td>可判断实例归属</td>
<td>不能判断原始类型&#x2F;null</td>
</tr>
<tr>
<td><code>Object.prototype.toString.call</code></td>
<td>所有类型</td>
<td>✅ 最准确</td>
<td>写法稍复杂</td>
</tr>
<tr>
<td><code>Array.isArray()</code></td>
<td>是否为数组</td>
<td>简洁，语义清晰</td>
<td>只能判断数组</td>
</tr>
<tr>
<td><code>constructor</code></td>
<td>判断构造函数</td>
<td>有时好用</td>
<td>不安全，可被修改</td>
</tr>
</tbody></table>
<blockquote>
<p>为什么typeof null &#x3D;&#x3D;&#x3D; ‘object’是对的？<br>JS 历史遗留 bug，底层表示为 null 的二进制是全 0，而 typeof 误判为 object。</p>
</blockquote>
<ul>
<li>类型转换</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;121yyy32.9079478&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(str)); <span class="comment">//12132</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(str));<span class="comment">//type:number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(str));<span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(str));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">toString</span>());</span><br><span class="line"><span class="title class_">String</span>(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐式转换</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span>+num);<span class="comment">//==&quot;&quot;.concat(num);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//保留小数位数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toFixed</span>(<span class="number">2</span>));<span class="comment">//返回字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uri=<span class="string">&quot;http://.....html?name=zhangsan&quot;</span>;</span><br><span class="line"><span class="comment">//uri编码</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">encodeURI</span>(uri))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">encodeURIComponent</span>(uri))<span class="comment">//完全解析 ? =都解析出来</span></span><br><span class="line"><span class="comment">//uri解码</span></span><br><span class="line"><span class="built_in">decodeURI</span>()</span><br><span class="line"><span class="built_in">decodeURIComponent</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>隐式类型转换</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只写正确的，其他都是错的</span></span><br><span class="line"><span class="literal">null</span>==<span class="literal">undefined</span> </span><br><span class="line"><span class="string">&#x27;&#x27;</span>==<span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> a=&#123;</span><br><span class="line">  <span class="attr">value</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">valueOf</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a==<span class="number">1</span>&amp;&amp;a==<span class="number">2</span>&amp;&amp;a==<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj + <span class="number">1</span>); <span class="comment">// 输出5</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优先级：Symbol.toPrimitive-&gt;valueOf-&gt;toString</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span> + &#123;&#125;</span><br><span class="line"><span class="comment">// &quot;10[object Object]&quot;，注意：&#123;&#125;默认调用valueOf是&#123;&#125;，不是基础类型继续转换，调用toString，返回结果&quot;[object Object]&quot;，于是和10进行&#x27;+&#x27;运算，按照字符串拼接规则</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="literal">undefined</span>,<span class="number">4</span>,<span class="number">5</span>] + <span class="number">10</span></span><br><span class="line"><span class="comment">// &quot;1,2,,4,510&quot;，注意[1,2,undefined,4,5]默认先调用valueOf结果还是这个数组，不是基础数据类型继续转换，调用toString，返回&quot;1,2,,4,5&quot;再和10进行运算，按照字符串拼接规则</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Object.is():    用来比较两个值是否相等</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol>
<li>算数运算符<br>次方<code>**</code> </li>
<li>逻辑运算符<br>常用<code>&amp;&amp; ||  !</code></li>
<li>三目&#x2F;三元运算符<br><code>条件?真run：假run</code></li>
<li>比较运算符<br> <code>===</code>对应<code>!==</code>，<br> <strong>&#x3D;&#x3D;&#x3D;不会自动转换数据类型</strong>，如果数据类型不一致，返回false，如果一致，再比较。<br> undefined 和 null 与其自身严格相等</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = (<span class="literal">null</span> === <span class="literal">null</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> res2 = (<span class="literal">undefined</span> === <span class="literal">undefined</span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>尽量不要使用&#x3D; &#x3D;比较，<strong>始终坚持使用&#x3D; &#x3D; &#x3D;比较</strong>。<br><code>==</code>做类型转换，再进行值的比较</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = (<span class="literal">null</span> == <span class="literal">undefined</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> res2 = (<span class="literal">null</span>  === <span class="literal">undefined</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code> !=</code> 和 <code>!==</code>和<code>!===</code><br><code>!= </code>是非严格不等于，允许类型转换。<br><code>!== </code>是严格不等于，不允许类型转换。<br><code>!=== </code>是无效的运算符，不能使用。</li>
</ul>
<ol start="5">
<li>赋值运算符</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c+=<span class="number">5</span>;</span><br><span class="line">c++;</span><br></pre></td></tr></table></figure>
<p>1、11 + “12”+ 13 的结果是什么？ “111213”<br>2、true + false + 1 + “”的结果是什么？2<br>上述两个都会强行转换成数字类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;123.321test&quot;</span>));  <span class="comment">// 结果：123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&quot;123.321test&quot;</span>)); <span class="comment">// 结果：123.321</span></span><br><span class="line"><span class="comment">//parseInt 从字符串开头开始解析整数部分，遇到 .（小数点）后会停止解析。</span></span><br><span class="line"><span class="comment">//parseFloat 解析浮点数，包括小数部分，直到遇到非数值字符。</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>一元正号（Unary plus）将一个值强制转换为数字类型（Number）：就是在值前面放<code>+</code></li>
</ol>
<p>类似的还有：<code>~~</code>去除小数部分 <code>!!</code>转换成bool值</p>
<ol start="6">
<li><code>??</code>空值合并运算符（Nullish Coalescing）<br>  作用：当左边是 null 或 undefined 时，才返回右边的值。</li>
<li><code>?.</code>可选链操作符（Optional Chaining）<br>  作用：在访问对象深层属性时，如果某一层为 null 或 undefined，不会报错，而是返回 undefined</li>
</ol>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li>循环<br>for &#x2F;while &#x2F;do…while</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;s.<span class="property">length</span>;j++)&#123;&#125;</span><br><span class="line"><span class="keyword">while</span>(xx)&#123;&#125;</span><br><span class="line"><span class="keyword">do</span> &#123; ... &#125; <span class="keyword">while</span>()<span class="comment">//先执行一次 再判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>switch case性能优于if else</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断简化</span></span><br><span class="line"><span class="keyword">if</span>(a === <span class="literal">undefined</span> || a === <span class="number">10</span> || a=== <span class="number">15</span> || a === <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>([<span class="literal">undefined</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="literal">null</span>].<span class="title function_">includes</span>(a)) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">10</span>) &#123;</span><br><span class="line">	<span class="title function_">doSomething</span>(a)</span><br><span class="line">&#125;</span><br><span class="line">a &gt; <span class="number">10</span> &amp;&amp; <span class="title function_">doSomething</span>(a)</span><br><span class="line"></span><br><span class="line">a ?? <span class="title function_">dosomething</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(xx)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(xx)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三元运算符</span></span><br><span class="line">condition?<span class="attr">ok_then</span>:no_then</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>()&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="attr">label1</span>:</span><br><span class="line">		xxx</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="attr">label2</span>:</span><br><span class="line">		xxx</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="attr">default</span>:</span><br><span class="line">		xxx</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明 函数提升至作用域顶部</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="comment">// 函数表达式必须要先声明再调用</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x, y</span>) =&gt; x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name = <span class="string">&#x27;游客&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;你好，&#x27;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩余参数 变成数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值不写则返回undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传参过多的优化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getItem</span>(<span class="params">price, quantity, name, description</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">getItem</span>(<span class="number">15</span>, <span class="literal">undefined</span>, <span class="string">&#x27;bananas&#x27;</span>, <span class="string">&#x27;fruit&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getItem</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;price, quantity, name, description&#125; = args</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getItem</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;bananas&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">quantity</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="attr">description</span>: <span class="string">&#x27;fruit&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>箭头函数 v.s. 普通函数</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>普通函数 (<code>function</code>)</th>
<th>箭头函数 (<code>=&gt;</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>语法</td>
<td>冗长</td>
<td>简洁</td>
</tr>
<tr>
<td><code>this</code> 绑定方式</td>
<td>动态，谁调用指向谁</td>
<td>静态，指向定义时外部作用域</td>
</tr>
<tr>
<td>可作为构造函数使用</td>
<td>是</td>
<td>❌ 否</td>
</tr>
<tr>
<td>是否有 <code>arguments</code></td>
<td>有</td>
<td>❌ 没有</td>
</tr>
<tr>
<td>是否有 <code>super</code> &#x2F; <code>new.target</code></td>
<td>有</td>
<td>❌ 没有</td>
</tr>
</tbody></table>
<ul>
<li>总结</li>
</ul>
<ol>
<li>函数内部声明的变量，在函数外部无法被访问</li>
<li>函数参数也是函数内部的局部变量</li>
<li>不同函数内部声明的变量无法互相访问</li>
<li>函数执行完毕后，函数内部变量实际被清空</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">parameter</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> parameter;</span><br><span class="line"><span class="comment">//return 只能返回一个值，如果有多个则返回最后一个</span></span><br><span class="line"><span class="comment">//无返回时是undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func=<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a+b;&#125;</span><br><span class="line"><span class="keyword">var</span> r=<span class="title function_">func</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数形参实参个数匹配</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2);</span><br><span class="line"><span class="comment">// 1. 如果实参的个数和形参的个数一致 则正常输出结果</span></span><br><span class="line">        <span class="title function_">getSum</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2. 如果实参的个数多于形参的个数  会取到形参的个数 </span></span><br><span class="line">        <span class="title function_">getSum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 3. 如果实参的个数小于形参的个数  多于的形参定义为undefined  最终的结果就是 NaN</span></span><br><span class="line"><span class="comment">// 形参可以看做是不用声明的变量  num2 是一个变量但是没有接受值  结果就是undefined </span></span><br><span class="line">        <span class="title function_">getSum</span>(<span class="number">1</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 建议 我们尽量让实参的个数和形参相匹配</span></span><br></pre></td></tr></table></figure>
<ul>
<li>IIFE（immediately invoked function expression）立即执行函数：创建闭包，保存全局作用域（window）和当前函数的作用域，因此可输出全局变量。是一种自执行匿名函数，匿名函数拥有独立作用域。不仅避免外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</li>
</ul>
<h3 id="return坑"><a href="#return坑" class="headerlink" title="return坑"></a>return坑</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 自动添加了分号，相当于return undefined;</span></span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;; <span class="comment">// 这行语句已经没法执行到了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以正确写法为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号，因为&#123;表示语句尚未结束</span></span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><table>
<thead>
<tr>
<th>环境</th>
<th>输入方式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>浏览器</td>
<td><code>prompt()</code></td>
<td><code>prompt(&quot;请输入&quot;)</code></td>
</tr>
<tr>
<td>浏览器</td>
<td>HTML + JS</td>
<td><code>input.value</code> + <code>button.onclick</code></td>
</tr>
<tr>
<td>Node.js</td>
<td><code>readline</code></td>
<td><code>rl.question(...)</code></td>
</tr>
</tbody></table>
<ul>
<li>在 Node.js 中获取输入</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&quot;readline&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">  <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">  <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.<span class="title function_">question</span>(<span class="string">&quot;请输入你的名字：&quot;</span>, <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`你好，<span class="subst">$&#123;name&#125;</span>！`</span>);</span><br><span class="line">  rl.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>json</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;data.json&quot;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;加载数据失败&quot;</span>, error));</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://jsonplaceholder.typicode.com/users/1&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;请求失败&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fetchData</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6 import</span></span><br><span class="line"><span class="keyword">import</span> userData <span class="keyword">from</span> <span class="string">&quot;./data.json&quot;</span> assert &#123; <span class="attr">type</span>: <span class="string">&quot;json&quot;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; user, getUser &#125; <span class="keyword">from</span> <span class="string">&quot;./data.js&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getUser</span>());</span><br><span class="line"><span class="comment">//data.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读取本地存储 (localStorage &#x2F; sessionStorage)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;user&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;));</span><br><span class="line"><span class="comment">//JSON.stringify converts a JavaScript value to a JSON string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="keyword">const</span> userData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;user&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userData);</span><br></pre></td></tr></table></figure>
<ul>
<li>txt,csv<br>浏览器的 File 对象（即 event.target.files[0]）不能直接访问内容，必须通过 FileReader 读取。<br>FileReader 是浏览器提供的 API，用于异步读取文件内容，它支持以下格式：<br>readAsText(file) —— 读取文本（如 .txt, .csv, .json）。<br>readAsDataURL(file) —— 读取图片并返回 Base64 编码。<br>readAsArrayBuffer(file) —— 读取二进制数据。<br>readAsBinaryString(file) —— 读取二进制字符串（已废弃）。<br>为什么必须写 onload？<br>readAsText(file) 是异步操作，读取文件需要时间，所以不能直接在下一行获取 result。必须等 onload 事件触发，文件数据才会被正确读取。<br>1️⃣ dragover 事件<br>当文件被拖动到 dropArea 上方时触发。<br>默认情况下，浏览器不允许放置文件，e.preventDefault(); 使其成为可拖拽区域。<br>2️⃣ drop 事件<br>当文件被放下时触发。<br>默认行为是打开文件，但我们希望自己控制读取文件，因此 e.preventDefault(); 阻止这个默认行为。</li>
</ul>
<p>可将读取到的文本转换成json</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;./data.txt&quot;</span>) <span class="comment">// 读取 txt 文件</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">text</span>()) <span class="comment">// 读取文本内容</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">text</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> jsonData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(text); <span class="comment">// 将文本转换为 JSON</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(jsonData); <span class="comment">// 输出 JSON 数据</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;JSON 解析失败:&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;读取文件失败:&quot;</span>, err));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1 </span></span><br><span class="line"><span class="comment">不适用于：直接打开 HTML 文件时（因浏览器安全限制）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">fetch(&quot;example.txt&quot;)</span><br><span class="line">    .then(response =&gt; response.text())</span><br><span class="line">    .then(data =&gt; console.log(data))</span><br><span class="line">    .catch(error =&gt; console.error(&quot;读取文件失败&quot;, error));</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileInput&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;fileInput&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> file = event.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span></span><br><span class="line"><span class="language-javascript">    reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">result</span>); <span class="comment">// 读取的文件内容</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">    reader.<span class="title function_">readAsText</span>(file);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dropArea&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 300px; height: 150px; border: 2px dashed gray; text-align: center; line-height: 150px;&quot;</span>&gt;</span></span><br><span class="line">    拖拽 TXT 文件到此处</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">&quot;fileContent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">pre是一个 HTML 标签，常用于显示文本内容，尤其是保留换行和空格格式的文本。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> dropArea = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;dropArea&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">dropArea.<span class="title function_">addEventListener</span>(<span class="string">&quot;dragover&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    e.<span class="title function_">preventDefault</span>(); <span class="comment">// 允许拖拽</span></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">dropArea.<span class="title function_">addEventListener</span>(<span class="string">&quot;drop&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    e.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> file = e.<span class="property">dataTransfer</span>.<span class="property">files</span>[<span class="number">0</span>]; <span class="comment">// 获取拖拽的文件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (!file || file.<span class="property">type</span> !== <span class="string">&quot;text/plain&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;请选择一个 TXT 文件！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span></span><br><span class="line"><span class="language-javascript">    reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;fileContent&quot;</span>).<span class="property">textContent</span> = event.<span class="property">target</span>.<span class="property">result</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">    reader.<span class="title function_">readAsText</span>(file);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>读取数据库</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://example.com/api/users&quot;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data));</span><br></pre></td></tr></table></figure>
<h3 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h3><p>在HTML表单中，上传文件唯一控件是&lt; input type&#x3D;”file”&gt;，表单enctype必须指定为multipart&#x2F;form-data，method必须指定为post，浏览器才能正确编码并以multipart&#x2F;form-data格式发送表单数据。<br>出于安全考虑，浏览器只允许用户选择本地文件，用JavaScript对&lt; input type&#x3D;”file”&gt;的value赋值是没有任何效果的。<br>JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-file-upload&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> filename = f.<span class="property">value</span>; <span class="comment">// &#x27;C:\fakepath\test.png&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (!filename || !(filename.<span class="title function_">endsWith</span>(<span class="string">&#x27;.jpg&#x27;</span>) || filename.<span class="title function_">endsWith</span>(<span class="string">&#x27;.png&#x27;</span>) || filename.<span class="title function_">endsWith</span>(<span class="string">&#x27;.gif&#x27;</span>))) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Can only upload image file.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HTML5新增的File API允许JavaScript读取文件内容，获得更多文件信息。提供File和FileReader两个主要对象，可获得文件信息并读取文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-image-file&#x27;</span>),</span><br><span class="line">    info = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-file-info&#x27;</span>),</span><br><span class="line">    preview = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-image-preview&#x27;</span>);</span><br><span class="line"><span class="comment">// 监听change事件:</span></span><br><span class="line">fileInput.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 清除背景图片:</span></span><br><span class="line">    preview.<span class="property">style</span>.<span class="property">backgroundImage</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 检查文件是否选择:</span></span><br><span class="line">    <span class="keyword">if</span> (!fileInput.<span class="property">value</span>) &#123;</span><br><span class="line">        info.<span class="property">innerHTML</span> = <span class="string">&#x27;没有选择文件&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取File引用:</span></span><br><span class="line">    <span class="keyword">var</span> file = fileInput.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取File信息:</span></span><br><span class="line">    info.<span class="property">innerHTML</span> = <span class="string">&#x27;文件: &#x27;</span> + file.<span class="property">name</span> + <span class="string">&#x27;&lt;br&gt;&#x27;</span> +</span><br><span class="line">                     <span class="string">&#x27;大小: &#x27;</span> + file.<span class="property">size</span> + <span class="string">&#x27;&lt;br&gt;&#x27;</span> +</span><br><span class="line">                     <span class="string">&#x27;修改: &#x27;</span> + file.<span class="property">lastModifiedDate</span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="property">type</span> !== <span class="string">&#x27;image/jpeg&#x27;</span> &amp;&amp; file.<span class="property">type</span> !== <span class="string">&#x27;image/png&#x27;</span> &amp;&amp; file.<span class="property">type</span> !== <span class="string">&#x27;image/gif&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;不是有效的图片文件!&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件:</span></span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">    <span class="comment">// FileReader() 返回一个新构造的FileReader。</span></span><br><span class="line">    <span class="comment">//当 FileReader 读取文件的方式为  </span></span><br><span class="line">    <span class="comment">//readAsArrayBuffer, </span></span><br><span class="line">    <span class="comment">//readAsBinaryString, </span></span><br><span class="line">    <span class="comment">//readAsDataURL 或者 readAsText 的时候，会触发一个 load 事件。从而可以使用  FileReader.onload 属性对该事件进行处理。</span></span><br><span class="line">    reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> data = e.<span class="property">target</span>.<span class="property">result</span>; </span><br><span class="line"><span class="comment">// &#x27;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&#x27;            </span></span><br><span class="line">        preview.<span class="property">style</span>.<span class="property">backgroundImage</span> = <span class="string">&#x27;url(&#x27;</span> + data + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 以DataURL的形式读取文件:</span></span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line"><span class="comment">//readAsDataURL 方法会读取指定的 Blob 或 File 对象。</span></span><br><span class="line"><span class="comment">//读取操作完成的时候，readyState 变成已完成DONE，并触发 loadend 事件，</span></span><br><span class="line"><span class="comment">//result属性将包含一个data:URL格式的字符串（base64编码）以表示所读取文件的内容。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="*严格模式"></a>*严格模式</h2><p>严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。<br>严格模式对正常的 JavaScript 语义做了一些更改：<br>1.消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。<br>2.消除代码运行的一些不安全之处，保证代码运行的安全。<br>3.提高编译器效率，增加运行速度。<br>4.禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class,enum,export, extends, import, super 不能做变量名</p>
<ul>
<li>开启严格模式<br>严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为脚本开启严格模式和为函数开启严格模式两种情况。</li>
</ul>
<ol>
<li>脚本开启严格模式<br>有的 script 脚本是严格模式，有的 script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他script 脚本文件。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//在当前的这个自调用函数中有开启严格模式，当前函数之外还是普通模式</span></span><br><span class="line">　　　　<span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">       <span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">　　　　<span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//或者 </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="meta"></span></span></span></span><br><span class="line"><span class="meta"><span class="language-javascript"><span class="language-xml">  　&quot;use strict&quot;</span>; <span class="comment">//当前script标签开启了严格模式</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  			<span class="comment">//当前script标签未开启严格模式</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>函数开启严格模式<br>要给某个函数开启严格模式，需要把“use strict”;  (或 ‘use strict’; ) 声明放在函数体所有语句之前。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　<span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">　　<span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//当前fn函数开启了严格模式</span></span><br></pre></td></tr></table></figure>
<ul>
<li>严格模式产生的改变</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line">num = <span class="number">10</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num)<span class="comment">//严格模式后不能使用未声明的变量</span></span><br><span class="line">------------------</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> num2;<span class="comment">//严格模式不允许删除变量</span></span><br><span class="line">------------------</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 严格模式下全局作用域中函数中的 this 是 undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();  </span><br><span class="line">------------------</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params"></span>) &#123;</span><br><span class="line">	 <span class="variable language_">this</span>.<span class="property">sex</span> = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Star();严格模式下,如果构造函数不加new调用, this 指向的是undefined 如果给他赋值则会报错.</span></span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh.<span class="property">sex</span>);</span><br><span class="line">--------------------</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//严格模式下，定时器 this 还是指向 window</span></span><br><span class="line">&#125;, <span class="number">2000</span>);  </span><br></pre></td></tr></table></figure>
<h2 id="预解析"><a href="#预解析" class="headerlink" title="*预解析"></a>*预解析</h2><ul>
<li>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义。预解析也叫做变量、函数提升。<br> 预解析会把变量和函数的声明在代码执行之前执行完成。</li>
<li>变量预解析<br>  变量提升（变量预解析）： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num);  <span class="comment">// 结果是多少？</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;      </span><br><span class="line"><span class="comment">//结果：undefined,变量提升只提升声明，不提升赋值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数预解析<br>  函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。函数表达式不存在提升的现象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;打印&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：控制台打印字符串 — ”打印“<br>注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！	</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="keyword">var</span>  fn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;想不到吧&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：报错提示 ”fn is not a function”<br>解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用</p>
<h1 id="对象-数组"><a href="#对象-数组" class="headerlink" title="对象 &amp; 数组"></a>对象 &amp; 数组</h1><ul>
<li>查找文档：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/">MDN</a></li>
</ul>
<h2 id="堆、栈"><a href="#堆、栈" class="headerlink" title="堆、栈"></a>堆、栈</h2><ul>
<li>堆栈空间分配区别：<br>　　1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；简单数据类型存放到栈里面<br>　　　　　　　　　　　　2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</li>
<li>简单数据类型的存储方式<br>    值类型变量的数据直接存放在变量（栈空间）中<br>  <img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/10bba105428847618ad26b8337dd8a24.png" alt="在这里插入图片描述"></li>
<li>复杂数据类型的存储方式<br>    引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中<br>  <img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/c94a0174d4cd4daeb24f52959ecb3a23.png" alt="在这里插入图片描述"></li>
<li>简单类型传参<br>函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="title function_">fn</span>(x);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x)；</span><br><span class="line"><span class="comment">//	运行结果如下：</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>复杂数据类型传参<br>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">x</span>) &#123; <span class="comment">// x = p</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">name</span>); <span class="comment">// 2. 这个输出什么 ?    </span></span><br><span class="line">    x.<span class="property">name</span> = <span class="string">&quot;张学友&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">name</span>); <span class="comment">// 3. 这个输出什么 ?    </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>);    <span class="comment">// 1. 这个输出什么 ?   </span></span><br><span class="line"><span class="title function_">f1</span>(p);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>);    <span class="comment">// 4. 这个输出什么 ?  </span></span><br></pre></td></tr></table></figure>
<h2 id="new专题"><a href="#new专题" class="headerlink" title="new专题"></a>new专题</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/U12P3UAGXR9w5CQaqZVZiA">点击跳转</a></p>
<h2 id="数字安全专题-（0-1-0-2-0-3-的原因）"><a href="#数字安全专题-（0-1-0-2-0-3-的原因）" class="headerlink" title="数字安全专题 （0.1+0.2!&#x3D;&#x3D;0.3 的原因）"></a>数字安全专题 （0.1+0.2!&#x3D;&#x3D;0.3 的原因）</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41775119/article/details/147121040?fromshare=blogdetail&sharetype=blogdetail&sharerId=147121040&sharerefer=PC&sharesource=qq_41775119&sharefrom=from_link">点击跳转</a><br>总结：JS数字采用 IEEE 754 标准 64 位双精度浮点数，1-11-52，用科学记数法表示指数和尾数，过长小数会被截断，导致精度误差。解决方法：高精度数值库Decimal.js；在ES6中，提供了Number.EPSILON属性，而它的值就是$2^{-52}$</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">numberepsilon</span>(<span class="params">arg1,arg2</span>)&#123;                   </span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(arg1 - arg2) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span>;        </span><br><span class="line">&#125;        </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numberepsilon</span>(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="包装对象（Wrapper-Objects）"><a href="#包装对象（Wrapper-Objects）" class="headerlink" title="包装对象（Wrapper Objects）"></a>包装对象（Wrapper Objects）</h2><ol>
<li>JavaScript 不会把所有基本数据类型“始终”包装为复杂数据类型。只会在需要对基本数据类型进行“对象式操作”（即调用其方法或访问其属性）时，临时地将它们包装成对应的对象，操作完成后立即销毁这个临时对象。<br>JavaScript 引擎在后台自动进行以下步骤：<br>1）创建临时包装对象： 根据基本数据类型，创建对应“包装对象”实例。<br>对于 string，创建 String 对象。<br>对于 number，创建 Number 对象。<br>对于 boolean，创建 Boolean 对象。<br>2）执行操作： 在这个临时包装对象上执行调用方法或访问属性。<br>3）销毁临时对象： 操作完成后，这个临时包装对象立即销毁。</li>
<li>JavaScript 称为“弱类型”或“动态类型”语言，灵活性，得益于这种包装对象的机制。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 生成临时变量，把简单类型包装为复杂数据类型</span></span><br><span class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;andy&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 调用相关方法</span></span><br><span class="line"><span class="keyword">let</span> upperStr = temp.<span class="title function_">toUpperCase</span>();</span><br><span class="line"><span class="comment">// 3. 销毁临时变量</span></span><br><span class="line">temp = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h2 id="对象object"><a href="#对象object" class="headerlink" title="对象object"></a>对象object</h2><ul>
<li>JavaScript 一切皆对象，有各自的构造函数&#x2F;方法属性&#x2F;实例化。</li>
<li>空间存储<br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/51806601302349de82569ca97ed0b50f.png" alt="在这里插入图片描述"><br>普通对象在赋值时只是赋值栈内存中的地址，不是堆内存中的数据。<ul>
<li>堆与栈的区别：<br>1.堆和栈是内存中的数据存储空间<br>2.简单类型的数据保存在内存的栈空间中<br>3.引用类型的数据保存在内存的堆空间中，栈内存中存取的是引用类型的地址</li>
</ul>
</li>
<li>定义：JavaScript对象是一组由键-值组成的无序集合，键都是字符串类型（自动转为字符串，除了Symbol唯一不会被覆盖），值可以是任意数据类型。</li>
<li>使用</li>
</ul>
<ol>
<li>创建</li>
</ol>
<table>
<thead>
<tr>
<th>创建方式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>字面量</td>
<td><code>const obj = &#123; name: &#39;Tom&#39;, age: 18 &#125;;</code></td>
</tr>
<tr>
<td>构造函数</td>
<td><code>const obj = new Object();</code></td>
</tr>
<tr>
<td>工厂函数</td>
<td><code>function createUser() &#123; return &#123;...&#125; &#125;</code></td>
</tr>
<tr>
<td><code>Object.create(proto)</code></td>
<td><code>const obj = Object.create(null);</code></td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">tags</span>: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;mobile&#x27;</span>],</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;Beijing&#x27;</span>,</span><br><span class="line">    <span class="attr">hasCar</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">zipcode</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">habit</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="title function_">alert</span>(<span class="string">&#x27;habit&#x27;</span>) <span class="keyword">return</span><span class="string">&#x27;ok&#x27;</span>;&#125;,</span><br><span class="line">  	[dynamic]:<span class="string">&#x27;666&#x27;</span><span class="comment">//key可以是变量 比如[dynamic]得到其值作为key</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用构造函数创建对象</span></span><br><span class="line">        <span class="comment">// 构造函数的语法格式</span></span><br><span class="line">        <span class="comment">// function 构造函数名() &#123;</span></span><br><span class="line">        <span class="comment">//     this.属性 = 值;</span></span><br><span class="line">        <span class="comment">//     this.方法 = function() &#123;&#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// new 构造函数名();</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 1. 构造函数名字首字母要大写</span></span><br><span class="line"><span class="comment">// 2. 我们构造函数不需要return 就可以返回结果</span></span><br><span class="line"><span class="comment">// 3. 我们调用构造函数 必须使用 new</span></span><br><span class="line"><span class="comment">// 4. 我们的属性和方法前面必须添加 this</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">uname, age, sex</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">name</span> = uname;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params">sang</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(sang);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>); </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>基本操作</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(ldh.<span class="property">name</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(ldh[<span class="string">&#x27;sex&#x27;</span>]);</span><br><span class="line">        ldh.<span class="title function_">sing</span>(<span class="string">&#x27;冰雨&#x27;</span>);</span><br><span class="line"><span class="comment">//新增修改</span></span><br><span class="line">obj.<span class="property">age</span> = <span class="number">20</span>;        <span class="comment">// 修改</span></span><br><span class="line">obj.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span>;   <span class="comment">// 新增</span></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">delete</span> object.<span class="property">p</span> <span class="comment">//只能删除对象属性或数组元素</span></span><br><span class="line"><span class="comment">//不能删除变量、函数、常量，不会更新length</span></span><br><span class="line"><span class="comment">//删除数组元素会留下“空洞”，即该位置的值为 undefined。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要检测xiaoming是否拥有某属性，可以用in操作符</span></span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;grade&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br><span class="line"><span class="comment">//如果in判断一个属性存在，这个属性不一定是xiaoming的，可能是xiaoming继承得到的</span></span><br><span class="line"><span class="comment">//要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法</span></span><br><span class="line">xiaoming.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>); <span class="comment">// false</span></span><br><span class="line">xiaoming.<span class="title function_">isPrototypeOf</span>(obj)<span class="comment">//检查当前对象是否是另一个对象的原型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浅拷贝 只复制一层</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source)<span class="comment">//将 source对象的所有属性复制到 target 对象。</span></span><br><span class="line"><span class="comment">//覆盖规则：后覆盖前</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj &#125;;</span><br><span class="line"><span class="keyword">const</span> obj3 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> source1 = &#123; <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> source2 = &#123; <span class="attr">d</span>: <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> 新对象 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, target, source1, source2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(新的对象); <span class="comment">// &#123; a: 1, b: 3, c: 4, d: 5 &#125;</span></span><br><span class="line"><span class="comment">//深拷贝 更强大的深拷贝，使用 lodash.cloneDeep</span></span><br><span class="line"><span class="keyword">const</span> deepCopy = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)); </span><br><span class="line"><span class="comment">// ⚠️ 不能拷贝函数、undefined、symbol</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象合并</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> merged = &#123; ...obj1, ...obj2 &#125;; <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj)<span class="comment">//冻结对象，防止后续修改对象的属性。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">//用来比较两个值是否相等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 不能直接用for of</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)<span class="comment">//返回对象的所有属性名（键）组成的数组。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj)<span class="comment">//返回对象的所有属性值组成的数组。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)<span class="comment">//返回对象的所有属性键值对组成的二维数组。</span></span><br><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="title class_">Object</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title function_">keys</span>(json))&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> <span class="title function_">values</span>(json))&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="title function_">entries</span>(json))&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, val] <span class="keyword">of</span> <span class="title function_">entries</span>(json))&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(key, val);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(k); <span class="comment">// k 变量 输出  得到的是 属性名</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(obj[k]); <span class="comment">// obj[k] 得到是 属性值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6特性</span></span><br><span class="line"><span class="keyword">let</span> json =&#123;<span class="comment">//简化</span></span><br><span class="line">            name,   <span class="comment">//name:name,</span></span><br><span class="line">            age ,    <span class="comment">//age:age</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">/* showA:function()&#123;</span></span><br><span class="line"><span class="comment">                return this.name;</span></span><br><span class="line"><span class="comment">            &#125; */</span></span><br><span class="line">            <span class="title function_">showA</span>(<span class="params"></span>)&#123;<span class="comment">//不要用箭头函数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手写深拷贝：所有层都可以拷贝下来</span></span><br><span class="line">		<span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">function</span> <span class="title function_">kaobei</span> (<span class="params">newObj, obj</span>) &#123;</span><br><span class="line">			<span class="comment">// 遍历</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( obj[key] <span class="keyword">instanceof</span> <span class="title class_">Array</span> ) &#123; <span class="comment">// obj[key] 是数组</span></span><br><span class="line">					<span class="comment">// obj[key]是数组</span></span><br><span class="line">					newObj[key] = [];</span><br><span class="line"></span><br><span class="line">					<span class="title function_">kaobei</span>(newObj[key], obj[key]);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj[key] <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;<span class="comment">// obj[key] 是对象</span></span><br><span class="line">					<span class="comment">// obj[key]再遍历拷贝</span></span><br><span class="line">					newObj[key] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">					<span class="title function_">kaobei</span>(newObj[key], obj[key]);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					newObj[key] = obj[key];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>( obj, newObj );</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="title function_">kaobei</span>(newObj, obj);</span><br></pre></td></tr></table></figure>
<h2 id="哈希表Map"><a href="#哈希表Map" class="headerlink" title="哈希表Map"></a>哈希表Map</h2><table>
<thead>
<tr>
<th>特性</th>
<th><code>Map</code></th>
<th><code>Object</code></th>
</tr>
</thead>
<tbody><tr>
<td>键类型</td>
<td>任意类型（对象、函数、基本类型）</td>
<td>只能是字符串或符号Symbol</td>
</tr>
<tr>
<td>键值顺序</td>
<td>有序（按插入顺序）</td>
<td>无序</td>
</tr>
<tr>
<td>可迭代性</td>
<td>可直接使用 <code>for...of</code> 遍历</td>
<td>不能直接迭代</td>
</tr>
<tr>
<td>获取大小</td>
<td><code>.size</code> 属性</td>
<td>必须手动计算</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>方法 &#x2F; 语法</th>
<th>示例代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>创建 Map</strong></td>
<td><code>new Map()</code></td>
<td><code>const map = new Map();</code></td>
<td>创建一个空的 Map</td>
</tr>
<tr>
<td><strong>创建 Map（带值）</strong></td>
<td><code>new Map([[key1, val1], [key2, val2]])</code></td>
<td><code>const map = new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2]]);</code></td>
<td>创建时直接初始化</td>
</tr>
<tr>
<td><strong>添加键值对</strong></td>
<td><code>.set(key, value)</code></td>
<td><code>map.set(&#39;name&#39;, &#39;Alice&#39;);</code></td>
<td>添加或更新键值对</td>
</tr>
<tr>
<td><strong>获取值</strong></td>
<td><code>.get(key)</code></td>
<td><code>map.get(&#39;name&#39;)</code></td>
<td>获取对应键的值</td>
</tr>
<tr>
<td><strong>检查键是否存在</strong></td>
<td><code>.has(key)</code></td>
<td><code>map.has(&#39;age&#39;)</code></td>
<td>判断 Map 中是否有该键</td>
</tr>
<tr>
<td><strong>删除键值对</strong></td>
<td><code>.delete(key)</code></td>
<td><code>map.delete(&#39;age&#39;)</code></td>
<td>删除指定键的条目</td>
</tr>
<tr>
<td><strong>清空 Map</strong></td>
<td><code>.clear()</code></td>
<td><code>map.clear()</code></td>
<td>删除所有键值对</td>
</tr>
<tr>
<td><strong>获取 Map 大小</strong></td>
<td><code>.size</code></td>
<td><code>map.size</code></td>
<td>获取键值对数量</td>
</tr>
<tr>
<td><strong>遍历所有键值对</strong></td>
<td><code>for (const [k, v] of map)</code></td>
<td><code>for (const [k, v] of map) &#123; console.log(k, v); &#125;</code></td>
<td>以插入顺序遍历键值对</td>
</tr>
<tr>
<td><strong>遍历所有键</strong></td>
<td><code>map.keys()</code></td>
<td><code>for (const k of map.keys())</code></td>
<td>遍历所有键</td>
</tr>
<tr>
<td><strong>遍历所有值</strong></td>
<td><code>map.values()</code></td>
<td><code>for (const v of map.values())</code></td>
<td>遍历所有值</td>
</tr>
<tr>
<td><strong>forEach 遍历</strong></td>
<td><code>map.forEach((v, k) =&gt; &#123;&#125;)</code></td>
<td><code>map.forEach((v, k) =&gt; console.log(k, v))</code></td>
<td>使用回调函数遍历</td>
</tr>
<tr>
<td><strong>使用对象做键</strong></td>
<td><code>map.set(obj, value)</code></td>
<td><code>map.set(&#123;id: 1&#125;, &#39;data&#39;)</code></td>
<td>可使用对象或函数作为键</td>
</tr>
<tr>
<td><strong>Map 转数组</strong></td>
<td><code>Array.from(map)</code> 或 <code>[...map]</code></td>
<td><code>const arr = [...map]</code></td>
<td>转换为数组</td>
</tr>
<tr>
<td><strong>数组转 Map</strong></td>
<td><code>new Map(array)</code></td>
<td><code>const map = new Map([[&#39;a&#39;, 1]])</code></td>
<td>使用二维数组创建 Map</td>
</tr>
</tbody></table>
<h3 id="map不是Map"><a href="#map不是Map" class="headerlink" title="map不是Map"></a>map不是Map</h3><p>一个是循环方法，一个是变量类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map的回调函数参数依次为value、key和map本身</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>]]);</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(key,value); <span class="comment">//设置一个值</span></span><br><span class="line">map.<span class="title function_">get</span>(key)    <span class="comment">//获取一个值</span></span><br><span class="line">map.<span class="title function_">delete</span>(key)    <span class="comment">//删除一项</span></span><br><span class="line">map.<span class="title function_">has</span>(key)    <span class="comment">//判断有没有</span></span><br><span class="line">map.<span class="title function_">clear</span>()    <span class="comment">//清空</span></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value, key);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">array.<span class="title function_">map</span>(callback)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遍历数组的每一项</span></span><br><span class="line"><span class="comment">对每一项执行 callback 函数</span></span><br><span class="line"><span class="comment">返回一个新的数组（不改变原数组）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><table>
<thead>
<tr>
<th>对比点</th>
<th><code>Map</code> ✅（强引用）</th>
<th><code>WeakMap</code> ✅（弱引用）</th>
</tr>
</thead>
<tbody><tr>
<td>键（key）类型</td>
<td>任意类型（基本类型 or 对象）</td>
<td>❗<strong>只能是对象</strong>（如 <code>&#123;&#125;</code> &#x2F; DOM 节点）</td>
</tr>
<tr>
<td>是否可迭代</td>
<td>可迭代（可用于 <code>for...of</code>）</td>
<td>❌ 不可迭代，不能枚举键&#x2F;值</td>
</tr>
<tr>
<td>是否可清空全部</td>
<td>支持 <code>.clear()</code> 清空</td>
<td>❌ 不支持 clear，只能逐个删除</td>
</tr>
<tr>
<td>垃圾回收影响</td>
<td>❌ 键强引用，<strong>不会被自动垃圾回收</strong></td>
<td>✅ 键是弱引用，<strong>对象没被引用会被自动清除</strong></td>
</tr>
<tr>
<td>典型用途</td>
<td>通用 key-value 数据结构</td>
<td>给对象绑定私有数据、缓存 DOM 节点等</td>
</tr>
<tr>
<td>是否适合缓存数据</td>
<td>普通缓存</td>
<td>✅ 更适合<strong>弱引用缓存，不会内存泄漏</strong></td>
</tr>
</tbody></table>
<h2 id="数组对象Array"><a href="#数组对象Array" class="headerlink" title="数组对象Array"></a>数组对象Array</h2><ul>
<li>有些数组方法不会改变原数组，有些则会改变原数组。<br>改变原数组的方法：fill()、pop()、push()、unshift&#x2F;shift()、splice()、unshift()、reverse()、sort()；forEach()</li>
</ul>
<table>
<thead>
<tr>
<th>原数组不变方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>map()</code></td>
<td>遍历并生成新数组</td>
</tr>
<tr>
<td><code>filter()</code></td>
<td>条件筛选出新数组</td>
</tr>
<tr>
<td><code>reduce()</code></td>
<td>聚合（如求和）</td>
</tr>
<tr>
<td><code>slice()</code></td>
<td>截取部分数组 （不含末尾）</td>
</tr>
<tr>
<td><code>concat()</code></td>
<td>合并数组</td>
</tr>
<tr>
<td><code>includes()</code></td>
<td>判断是否包含元素</td>
</tr>
<tr>
<td><code>join()</code></td>
<td>连接数组元素为字符串</td>
</tr>
<tr>
<td><code>toSorted()</code></td>
<td>排序返回新数组（ES2023）</td>
</tr>
</tbody></table>
<ul>
<li>sort排序算法原理：插入排序、快排。<br>当数组长度小于等于10的时候，采用插入排序，大于10的时候，采用快排。</li>
<li>判断两个数组值是否相等<br>不能用等号判断，它是比较引用地址的<br>用JSON.stringify()判断，但缺点是如果是对象或嵌套数组的复杂数组，会报错</li>
<li>检测是否为数组<br>instanceof 运算符：instanceof 可以判断一个对象是否是某个构造函数的实例</li>
</ul>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">23</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">23</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr));   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj));   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不要对数组用 in 来判断值是否存在<br>数组用 includes()，不要用 in，因为in是判断索引是否存在</li>
<li>清空数组最简单最快捷方法就是arr.length&#x3D;0</li>
<li>创建</li>
</ul>
<table>
<thead>
<tr>
<th>创建方式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>字面量</td>
<td><code>const arr = [1, 2, 3];</code></td>
</tr>
<tr>
<td>构造函数</td>
<td><code>new Array(3)</code> → [empty × 3]</td>
</tr>
<tr>
<td>Array.of</td>
<td><code>Array.of(&#39;apple&#39;,&#39;banana&#39;,&#39;orange&#39;)</code></td>
</tr>
<tr>
<td>arr.fill(填充东西, 开始位置, 结束位置);</td>
<td><code>Array.from(&#39;abc&#39;)</code> → <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>具备length属性的类数组都能转换</td>
</tr>
<tr>
<td>类数组转换成数组</td>
<td><code>[...arguments]</code></td>
</tr>
</tbody></table>
<ul>
<li>遍历<br>数组的 map 和 forEach 方法不支持提前结束循环，无法break 或 return 跳出循环。但是可以使用抛出异常方式来达到提前结束循环的效果。</li>
</ul>
<table>
<thead>
<tr>
<th>遍历方式</th>
<th>用法示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>for</code></td>
<td><code>for (let i = 0; i &lt; arr.length; i++)</code></td>
</tr>
<tr>
<td><code>for...of</code></td>
<td><code>for (let item of arr)</code></td>
</tr>
<tr>
<td><code>forEach</code></td>
<td><code>arr.forEach(item =&gt; …)</code></td>
</tr>
<tr>
<td><code>map</code>（返回新数组）</td>
<td><code>arr.map(item =&gt; item * 2)</code></td>
</tr>
<tr>
<td><code>filter</code>（筛选）</td>
<td><code>arr.filter(item =&gt; item &gt; 2)</code></td>
</tr>
<tr>
<td><code>reduce</code>（归并）</td>
<td><code>arr.reduce((a, b) =&gt; a + b, 0)</code></td>
</tr>
<tr>
<td><code>for...in</code>（❌不推荐）</td>
<td>遍历索引+原型链，不适合数组</td>
</tr>
<tr>
<td>some</td>
<td>只要一个true就提前返回true</td>
</tr>
<tr>
<td>every</td>
<td>必须所有都是true才是true，只要一个false就提前返回false</td>
</tr>
<tr>
<td>find &#x2F; findIndex</td>
<td>返回第一个通过测试的元素&#x2F;元素索引</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="title function_">push</span>(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//向Array的末尾添加若干元素</span></span><br><span class="line">a.<span class="title function_">pop</span>()<span class="comment">//把Array的最后一个元素删除掉</span></span><br><span class="line">a.<span class="title function_">unshift</span>(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//往Array的头部添加若干元素</span></span><br><span class="line">a.<span class="title function_">shift</span>(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//把Array的第一个元素删掉.</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">length</span></span><br><span class="line"><span class="comment">//直接给Array的length赋一个新的值会导致Array大小的变化(索引超过范围也可)。</span></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">6</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找元素</span></span><br><span class="line">a.<span class="title function_">indexOf</span>(<span class="string">&#x27;c&#x27;</span>)<span class="comment">//搜索一个指定的元素的位置。没找到返回-1</span></span><br><span class="line"><span class="comment">//lastIndexOf</span></span><br><span class="line">arr.<span class="title function_">includes</span>(<span class="number">3</span>);    <span class="comment">// 是否包含（ES7）</span></span><br><span class="line">arr.<span class="title function_">find</span>(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">2</span>);   <span class="comment">// 找第一个满足条件的值</span></span><br><span class="line">arr.<span class="title function_">findIndex</span>(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">2</span>); <span class="comment">// 找索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拍平成一维数组</span></span><br><span class="line">arr.<span class="title function_">flat</span>(depth) <span class="comment">//默认拍平一层</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]]]];</span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">flat</span>(<span class="number">1</span>);<span class="comment">//[1, 2, [3, [4]]]</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]]]].<span class="title function_">flat</span>(<span class="number">2</span>); <span class="comment">// [1, 2, 3, [4]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counts=<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">30</span>).<span class="title function_">fill</span>(<span class="number">0</span>);<span class="comment">//30个0</span></span><br><span class="line"><span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//二重数组</span></span><br><span class="line"><span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>)); <span class="comment">// ❌</span></span><br><span class="line"><span class="comment">//这种会生成 9 个对同一个数组的引用，导致修改一行所有行都会变！</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(list) </span><br><span class="line"></span><br><span class="line">a.<span class="title function_">toString</span>()<span class="comment">//元素连成一串，逗号分隔</span></span><br><span class="line"><span class="comment">//join()把当前Array的每个元素都用指定的字符串连接起来并返回 默认拼接用&#x27;,&#x27;</span></span><br><span class="line"><span class="comment">//如果Array元素不是字符串，将自动转换为字符串后再连接</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// &#x27;A-B-C-1-2-3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">a,b</span>)&#123;<span class="comment">//反着写可以实现降序 等价于return b-a;</span></span><br><span class="line">	<span class="keyword">if</span>(a&lt;b)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a&gt;b)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//等价于 return a-b</span></span><br><span class="line">&#125;</span><br><span class="line">a.<span class="title function_">sort</span>(compare);<span class="comment">//把所有元素先转换为String再排序，返回结果直接修改a</span></span><br><span class="line"><span class="comment">//字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前的Array和另一个Array连接起来，并返回一个新的Array</span></span><br><span class="line"><span class="comment">//并没有修改当前Array，而是返回了一个新的Array</span></span><br><span class="line"><span class="comment">//接收任意个元素的Array，自动把Array包含的括号拆掉，全部添加到新的Array里</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">concat</span>(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> result = [...arr1, ...arr2];  <span class="comment">// 使用扩展运算符追加数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//slice()对应String的substring()版本 前闭后开</span></span><br><span class="line"><span class="comment">//截取Array部分元素，返回新Array</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">arr.<span class="title function_">slice</span>(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: [&#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//splice万能方法:删除、插入、替换</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置（从1开始）。</span></span><br><span class="line"><span class="comment">howmany必需。要删除的项目数量。如果设置为 0，则不会删除项目。</span></span><br><span class="line"><span class="comment">item1, …, itemX —— 可选。向数组添加的新项目。</span></span><br><span class="line"><span class="comment">1.当不添加只删除时，没有可选参数，则（删除开始索引，删除个数）</span></span><br><span class="line"><span class="comment">2.当不删除只添加时，（添加开始索引，删除个数=0，items...）</span></span><br><span class="line"><span class="comment">3.删除且添加，（删除且添加的开始索引，删除个数，items...）</span></span><br><span class="line"><span class="comment">4.当删除个数等于添加个数时 实现替换功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Yahoo&#x27;</span>, <span class="string">&#x27;AOL&#x27;</span>, <span class="string">&#x27;Excite&#x27;</span>, <span class="string">&#x27;Oracle&#x27;</span>];</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤 filter</span></span><br><span class="line"><span class="keyword">var</span> r = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">element, index, self</span>) &#123;...&#125;)</span><br><span class="line"><span class="keyword">var</span> result=arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item,index,array</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> item&gt;<span class="number">10</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;  &#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s &amp;&amp; s.<span class="title function_">trim</span>(); <span class="comment">//IE9以下的版本没有trim()方法</span></span><br><span class="line">    <span class="comment">//trim()去除字符串两边的空白</span></span><br><span class="line">&#125;);</span><br><span class="line">r; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, index, array</span>) &#123;<span class="comment">//没有返回值</span></span><br><span class="line">       <span class="comment">//参数一是:当前数组元素值</span></span><br><span class="line">       <span class="comment">//参数二是:当前数组元素的索引</span></span><br><span class="line">       <span class="comment">//参数三是:当前的数组</span></span><br><span class="line">       <span class="comment">//可省略某些参数</span></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> isBreak = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;break&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">message</span> === <span class="string">&#x27;break&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;循环提前结束&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array.<span class="title function_">map</span>(callback)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遍历数组的每一项</span></span><br><span class="line"><span class="comment">对每一项执行 callback 函数</span></span><br><span class="line"><span class="comment">返回一个新的数组（不改变原数组）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把Array的所有数字转为字符串</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">arr.<span class="title function_">map</span>(<span class="title class_">String</span>); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;]</span></span><br><span class="line">r=[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>].<span class="title function_">map</span>(<span class="function"><span class="params">str</span> =&gt;</span> <span class="built_in">parseInt</span>(str));</span><br><span class="line"><span class="keyword">var</span> mapresult=arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item,index,array</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> item*<span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">array.<span class="property">map</span>（<span class="title class_">Number</span>） <span class="comment">//极简写法！！</span></span><br><span class="line">                                                    </span><br><span class="line"><span class="comment">//arr.map() 是数组专有的循环 非常有用，做数据交互映射，配合return，返回一个新数组，没有return时==foreach</span></span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, arr</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> json=&#123;&#125;;</span><br><span class="line">    json.<span class="property">t</span> = <span class="string">`^_^<span class="subst">$&#123;item.title&#125;</span>-----`</span>;<span class="comment">//将title内容增加了符号</span></span><br><span class="line">    json.<span class="property">r</span> = item.<span class="property">read</span>+<span class="number">200</span>;<span class="comment">//变更了read人数</span></span><br><span class="line">    json.<span class="property">hot</span> = item.<span class="property">hot</span> == <span class="literal">true</span> &amp;&amp; <span class="string">&#x27;真棒!!!&#x27;</span>;<span class="comment">//将true显示为其他内容</span></span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArr = arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">value, index,array</span>) &#123;</span><br><span class="line">  	 <span class="comment">//参数一是:数组元素</span></span><br><span class="line">     <span class="comment">//参数二是:数组元素的索引</span></span><br><span class="line">     <span class="comment">//参数三是:当前的数组</span></span><br><span class="line">     <span class="keyword">return</span> value &gt;= <span class="number">20</span>;</span><br><span class="line">  &#125;);<span class="comment">//返回新数组</span></span><br><span class="line"><span class="comment">//arr.filter() 过滤不合格 返回true 留下来</span></span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, arr</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.<span class="property">hot</span>==<span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr.some() 类似查找  数组里有某元素符合条件返回true</span></span><br><span class="line"><span class="comment">//arr.every() 数组里所有元素满足条件返回true</span></span><br><span class="line"><span class="keyword">let</span> b = arr.<span class="title function_">some</span>(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val==<span class="string">&#x27;banana2&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> b = arr.<span class="title function_">every</span>(<span class="function">(<span class="params">val, index, arr</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val%<span class="number">2</span>==<span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">arr.<span class="title function_">reduce</span>()  <span class="comment">//用来对数组中的所有元素进行累积计算，最终得到一个单一的结果(值/数组/类数组)。</span></span><br><span class="line">arr.<span class="title function_">reduceRight</span>()</span><br><span class="line"><span class="comment">//比如：求数组的和、阶乘</span></span><br><span class="line">array.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b);</span><br><span class="line"><span class="keyword">const</span> sum = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;, <span class="number">0</span>); <span class="comment">// 初始值是 0</span></span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...numbers)</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(...numbers)</span><br><span class="line"><span class="keyword">const</span> max = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator &gt; currentValue ? accumulator : currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arr.reduce(callback(accumulator, currentValue[, index, array]), initialValue);</span></span><br><span class="line"><span class="comment">accumulator：保存结果的容器累积器，保存上次函数调用的返回值，或者是初始化的 initialValue。</span></span><br><span class="line"><span class="comment">currentValue：当前正在处理的数组元素。</span></span><br><span class="line"><span class="comment">index（可选）：当前元素的索引。</span></span><br><span class="line"><span class="comment">array（可选）：原数组。</span></span><br><span class="line"><span class="comment">initialValue（可选）：累积器的初始值。</span></span><br><span class="line"><span class="comment">如果没有提供，则数组的第一个元素会被用作初始值，第二个元素会作为 currentValue 开始迭代。</span></span><br><span class="line"><span class="comment">如果数组为空，且没有提供 initialValue，reduce() 会抛出错误。如果提供了 initialValue，则直接返回它。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">arr.<span class="title function_">find</span>()<span class="comment">//查找，找出第一个符合条件的数组成员，如果没有找到，返回undefined</span></span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">find</span>(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val&gt;<span class="number">1000</span>;</span><br><span class="line">&#125;);</span><br><span class="line">arr.<span class="title function_">findIndex</span>()<span class="comment">// 找的是位置， 没找到返回-1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arr.reduce(function(prev,cur,index,arr)&#123;</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">&#125;, init);</span></span><br><span class="line"><span class="comment">prev ：上一次调用回调时的返回值，或者初始值 init;</span></span><br><span class="line"><span class="comment">cur ： 当前正在处理的数组元素；</span></span><br><span class="line"><span class="comment">index ：当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；</span></span><br><span class="line"><span class="comment">arr ：原数组；</span></span><br><span class="line"><span class="comment">init ：初始值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//reduce()从左到右累加数据，直到最后为一个值（也就是最终的结果）</span></span><br><span class="line">[x1, x2, x3, x4].<span class="title function_">reduce</span>(f) = <span class="title function_">f</span>(<span class="title function_">f</span>(<span class="title function_">f</span>(x1, x2), x3), x4)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> min_str=strs.<span class="title function_">reduce</span>(<span class="function">(<span class="params">min,str</span>)=&gt;</span><span class="title class_">Math</span>.<span class="title function_">min</span>(min,str.<span class="property">length</span>),<span class="title class_">Infinity</span>);</span><br><span class="line"><span class="comment">//Infinity是初始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//array</span></span><br><span class="line">arrayObject.<span class="title function_">splice</span>(index,howmany,item1,.....,itemX)</span><br><span class="line"><span class="comment">//数组中添加或删除项目，然后返回被删除的项目。该方法会改变原始数组。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参数	描述</span></span><br><span class="line"><span class="comment">index	必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</span></span><br><span class="line"><span class="comment">howmany	必需。要删除的项目数量。如果设置为 0，则不会删除项目。</span></span><br><span class="line"><span class="comment">item1, ..., itemX	可选。向数组添加的新项目。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回值 被删除的项目，如果没有删除元素，就返回一个空数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Array.from方法还可以接受第二个参数，</span></span><br><span class="line"><span class="comment">//作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组</span></span><br><span class="line"><span class="comment">//注意：如果是对象，那么属性需要写对应的索引</span></span><br><span class="line"> <span class="keyword">let</span> arrayLike = &#123; </span><br><span class="line">     <span class="string">&quot;0&quot;</span>: <span class="number">1</span>,</span><br><span class="line">     <span class="string">&quot;1&quot;</span>: <span class="number">2</span>,</span><br><span class="line">     <span class="string">&quot;length&quot;</span>: <span class="number">2</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> newAry = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike, <span class="function"><span class="params">item</span> =&gt;</span> item *<span class="number">2</span>)<span class="comment">//[2,4]</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">entries</span>() <span class="comment">//返回的是一个包含数组元素索引和对应值的迭代器（Iterator）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> copy = arr.<span class="title function_">slice</span>();</span><br><span class="line"><span class="keyword">const</span> copy2 = [...arr];</span><br><span class="line"><span class="comment">//去重</span></span><br><span class="line"><span class="keyword">const</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>&#x3D;&#x3D;多维数组&#x3D;&#x3D;<br>嵌套Array<br>举例子：<code>var arr = [[1, 2, 3], [400, 500, 600], &#39;-&#39;];</code></li>
</ul>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>500</td>
<td>600</td>
</tr>
<tr>
<td>-</td>
<td>undefined</td>
<td>undefined</td>
</tr>
</tbody></table>
<h2 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h2><p>没有索引index</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>示例代码</th>
</tr>
</thead>
<tbody><tr>
<td>添加元素</td>
<td><code>set.add(value)</code></td>
</tr>
<tr>
<td>删除元素</td>
<td><code>set.delete(value)</code></td>
</tr>
<tr>
<td>是否包含</td>
<td><code>set.has(value)</code></td>
</tr>
<tr>
<td>清空</td>
<td><code>set.clear()</code></td>
</tr>
<tr>
<td>长度</td>
<td><code>set.size</code></td>
</tr>
<tr>
<td>遍历</td>
<td><code>for/of</code>, <code>forEach</code>, <code>[...set]</code></td>
</tr>
<tr>
<td>并集</td>
<td><code>new Set([...a, ...b])</code></td>
</tr>
<tr>
<td>交集</td>
<td><code>new Set([...a].filter(x =&gt; b.has(x)))</code></td>
</tr>
<tr>
<td>差集</td>
<td><code>new Set([...a].filter(x =&gt; !b.has(x)))</code></td>
</tr>
<tr>
<td>对称差</td>
<td><code>new Set([...a, ...b].filter(x =&gt; !(a.has(x) &amp;&amp; b.has(x))))</code></td>
</tr>
<tr>
<td>子集</td>
<td><code>[...a].every(x =&gt; b.has(x))</code></td>
</tr>
<tr>
<td>创建</td>
<td><code>const s = new Set([1, 2, 3]);</code></td>
</tr>
</tbody></table>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><ul>
<li>内部按 UTF-16 编码（中文占两个字节）</li>
<li>字符串不可变<br>指里面值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。<br>当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间<br>由于字符串不可变，在<strong>大量拼接字符串</strong>会有效率问题<br>字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是也没有任何效果。<br>JavaScript为字符串提供常用方法，注意，调用方法不会改变原有字符串的内容，而是<strong>返回新字符串</strong>。<blockquote>
<p>到底可变不可变？重新赋值整个字符串-&gt;可变，单独修改其中字符-&gt;不可变</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">\b 空格blank <span class="comment">//转义字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分割</span></span><br><span class="line"><span class="comment">//正则表达式</span></span><br><span class="line"><span class="string">&#x27;a b   c&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;c&#x27;] </span></span><br><span class="line"><span class="comment">//一个空格隔开的字符串</span></span><br><span class="line"></span><br><span class="line">a b   c<span class="string">&#x27;.split(/\s+/); // [&#x27;</span>a<span class="string">&#x27;, &#x27;</span>b<span class="string">&#x27;, &#x27;</span>c<span class="string">&#x27;] //</span></span><br><span class="line"><span class="string">//至少一个空格隔开的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span>a,b, c  d<span class="string">&#x27;.split(/[\s\,]+/); // [&#x27;</span>a<span class="string">&#x27;, &#x27;</span>b<span class="string">&#x27;, &#x27;</span>c<span class="string">&#x27;, &#x27;</span>d<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">//至少一个空格或逗号隔开的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span>a,b;; c  d<span class="string">&#x27;.split(/[\s\,\;]+/); // [&#x27;</span>a<span class="string">&#x27;, &#x27;</span>b<span class="string">&#x27;, &#x27;</span>c<span class="string">&#x27;, &#x27;</span>d<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">//至少一个空格或逗号或分号隔开的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="string">&#x27;.split(&#x27;</span>,<span class="string">&#x27;);  // [&#x27;</span><span class="number">1</span><span class="string">&#x27;, &#x27;</span><span class="number">2</span><span class="string">&#x27;, &#x27;</span><span class="number">3</span><span class="string">&#x27;]</span></span><br><span class="line"><span class="string">[&#x27;</span>a<span class="string">&#x27;, &#x27;</span>b<span class="string">&#x27;].join(&#x27;</span>-<span class="string">&#x27;) // &#x27;</span>a-b<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//创建</span></span><br><span class="line"><span class="string">var str=&#x27;</span>ok<span class="string">&quot;fine&quot;</span>?\n<span class="string">&#x27;//转义字符\</span></span><br><span class="line"><span class="string">var a=&#x27;</span>nihao<span class="string">&#x27;+521;//支持隐式转换</span></span><br><span class="line"><span class="string">//如果&#x27;</span>也在内容中，用<span class="string">&quot;&quot;</span>括起来</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`第一行 //多行字符串</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 第一行</span></span><br><span class="line"><span class="comment">// 第二行</span></span><br><span class="line"><span class="comment">// 第三行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字符</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">charAt</span>(<span class="number">1</span>)      <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="number">1</span>]             <span class="comment">// &#x27;b&#x27; ✅ 推荐写法</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">charCodeAt</span>(<span class="number">1</span>)  <span class="comment">// 98（字符编码）</span></span><br><span class="line"><span class="string">&#x27;中&#x27;</span>.<span class="title function_">charCodeAt</span>(<span class="number">0</span>)    <span class="comment">// 返回 UTF-16 编码</span></span><br><span class="line"><span class="string">&#x27;中&#x27;</span>.<span class="title function_">codePointAt</span>(<span class="number">0</span>)   <span class="comment">// 返回完整 Unicode 编码 ✅</span></span><br><span class="line"><span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">20013</span>);  <span class="comment">// &#x27;中&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isAlphaNumeric</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> code = c.<span class="title function_">charCodeAt</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    (code &gt;= <span class="number">48</span> &amp;&amp; code &lt;= <span class="number">57</span>) ||  <span class="comment">// 0-9</span></span><br><span class="line">    (code &gt;= <span class="number">65</span> &amp;&amp; code &lt;= <span class="number">90</span>) ||  <span class="comment">// A-Z</span></span><br><span class="line">    (code &gt;= <span class="number">97</span> &amp;&amp; code &lt;= <span class="number">122</span>)    <span class="comment">// a-z</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找子串</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">includes</span>(<span class="string">&#x27;b&#x27;</span>)    <span class="comment">// true ✅</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;b&#x27;</span>)     <span class="comment">// 1 找不到返回-1</span></span><br><span class="line"><span class="comment">//lastIndexOf</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;a&#x27;</span>)  <span class="comment">// true ✅</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">endsWith</span>(<span class="string">&#x27;c&#x27;</span>)    <span class="comment">// true ✅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span>;</span><br><span class="line">s.<span class="title function_">indexOf</span>(<span class="string">&#x27;world&#x27;</span>); <span class="comment">// 返回7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//截取字符串</span></span><br><span class="line"><span class="string">&#x27;abcdef&#x27;</span>.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>);     <span class="comment">// &#x27;bcd&#x27; 支持负数</span></span><br><span class="line"><span class="string">&#x27;abcdef&#x27;</span>.<span class="title function_">substring</span>(<span class="number">1</span>, <span class="number">4</span>); <span class="comment">// &#x27;bcd&#x27;（不支持负数）</span></span><br><span class="line"><span class="string">&#x27;abcdef&#x27;</span>.<span class="title function_">substr</span>(<span class="number">1</span>, <span class="number">3</span>);    <span class="comment">// &#x27;bcd&#x27;（已废弃 ❌）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小写转换</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">toUpperCase</span>(); <span class="comment">// &#x27;ABC&#x27;</span></span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span>.<span class="title function_">toLowerCase</span>(); <span class="comment">// &#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="string">&#x27;abcabc&#x27;</span>.<span class="title function_">replace</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;x&#x27;</span>);       <span class="comment">// &#x27;xbcabc&#x27;（只替换第一个）</span></span><br><span class="line"><span class="string">&#x27;abcabc&#x27;</span>.<span class="title function_">replaceAll</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;x&#x27;</span>);    <span class="comment">// &#x27;xbcxbc&#x27; （ES2021）</span></span><br><span class="line"><span class="string">&#x27;abcabc&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/a/g</span>, <span class="string">&#x27;x&#x27;</span>);      <span class="comment">// &#x27;xbcxbc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//去除空格</span></span><br><span class="line"><span class="string">&#x27;  abc  &#x27;</span>.<span class="title function_">trim</span>();       <span class="comment">// &#x27;abc&#x27;</span></span><br><span class="line"><span class="string">&#x27;  abc  &#x27;</span>.<span class="title function_">trimStart</span>();  <span class="comment">// &#x27;abc  &#x27;</span></span><br><span class="line"><span class="string">&#x27;  abc  &#x27;</span>.<span class="title function_">trimEnd</span>();    <span class="comment">// &#x27;  abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> <span class="string">&#x27;hello&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(char); <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型转换</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;123&#x27;</span>)       <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12px&#x27;</span>)    <span class="comment">// 12</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">123</span>)         <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line">(<span class="number">123</span>).<span class="title function_">toString</span>()    <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">parseFloat</span>(str) <span class="comment">//解析一个字符串，并返回一个浮点数;</span></span><br><span class="line"><span class="comment">//parseFloat() 可以正确解析Infinity， 而 parseInt() 无法识别 Infinity ：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countChar</span>(<span class="params">str, char</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">split</span>(char).<span class="property">length</span> - <span class="number">1</span>;<span class="comment">//对字符串中的某个字符计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str.<span class="title function_">concat</span>(str1,str2,..)<span class="comment">//一般用+运算代替str.concat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s &amp;&amp; s.<span class="title function_">trim</span>()<span class="comment">//意思是</span></span><br><span class="line"><span class="keyword">if</span> (s) <span class="keyword">return</span> s.<span class="title function_">trim</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line"><span class="title function_">toLocaleLowerCase</span>()<span class="comment">//根据所在地区 不同大小写的规则</span></span><br><span class="line"><span class="title function_">toLocaleUpperCase</span>()</span><br><span class="line"></span><br><span class="line">str.<span class="title function_">startsWith</span>()</span><br><span class="line">str.<span class="title function_">endsWith</span>()</span><br><span class="line">str.<span class="title function_">repeat</span>(count)</span><br><span class="line">str.<span class="title function_">split</span>(separator, limit);</span><br><span class="line"><span class="comment">//separator（可选）：指定分隔符，可以是一个字符串或正则表达式。用于确定在哪里切分字符串。如果不传递该参数，整个字符串将作为一个单独的元素放入返回的数组。</span></span><br><span class="line"><span class="comment">//limit（可选）：限制返回的数组的最大长度。如果指定了 limit，split() 将最多返回 limit 个元素。</span></span><br><span class="line">str.<span class="title function_">replace</span>(old,<span class="keyword">new</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>substring v.s. substr【废弃】<br>substring() 和 substr() 都是字符串方法，用于截取字符串部分。区别在于参数不同。<br>substring(起始位置，结束位置)<br>substr(起始位置，字符数)</li>
</ul>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>实例方法 <code>toFixed</code> 用于设置保留小数位的长度，注意&#x3D;&#x3D;返回字符串&#x3D;&#x3D;<br>Number 可当做普通函数使用，强制转换成数值数据类型。</p>
<h2 id="数学对象Math"><a href="#数学对象Math" class="headerlink" title="数学对象Math"></a>数学对象Math</h2><table>
<thead>
<tr>
<th>属性、方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Math.PI</td>
<td>圆周率</td>
</tr>
<tr>
<td>Math.floor()</td>
<td>向下取整</td>
</tr>
<tr>
<td>Math.ceil()</td>
<td>向上取整</td>
</tr>
<tr>
<td>Math.round()</td>
<td>四舍五入版 就近取整   注意 -3.5   结果是  -3</td>
</tr>
<tr>
<td>Math.abs()</td>
<td>绝对值</td>
</tr>
<tr>
<td>Math.max()&#x2F;Math.min()</td>
<td>求最大和最小值<br>如果没有传入值，Math.max()返回Infinity，Math.min()返回-Infinity</td>
</tr>
<tr>
<td>Math.random()</td>
<td>获取范围在[0,1)内的随机值</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取指定范围内的随机整数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRandom</span>(<span class="params">min, max</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min + <span class="number">1</span>)) + min; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">E</span> <span class="comment">//e</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">LN10</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">LN2</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">LOG2E</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">PI</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">SQRT2</span> <span class="comment">//根号2</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">SQRT1_2</span> <span class="comment">//0.5的平方根</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>()</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>()</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>,arr);</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">ceil</span>(num)</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(num)</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(num)</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>() <span class="comment">//0&lt;=random&lt;1</span></span><br><span class="line"><span class="title function_">random</span>(<span class="number">0</span>,<span class="number">36</span>)<span class="comment">//0~36随机</span></span><br></pre></td></tr></table></figure>
<h2 id="日期对象date"><a href="#日期对象date" class="headerlink" title="日期对象date"></a>日期对象date</h2><p>Date是一个构造函数，需要实例化后才能使用<br>注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象<br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/a845dd86e16c4afb844d9d234e53806d.png" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//获取系统当前时间；</span></span><br><span class="line"><span class="keyword">let</span> date= <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;1949-10-01&#x27;</span>)<span class="comment">//指定时间</span></span><br><span class="line"><span class="keyword">var</span> oneday = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;December 25,1995 13:30:00&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> oneday2=<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1995</span>,<span class="number">11</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> oneday3=<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1995</span>,<span class="number">11</span>,<span class="number">25</span>,<span class="number">14</span>,<span class="number">30</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> future = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2019/5/1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">getDate</span>());<span class="comment">//获取月份的第几天1～31</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">getMonth</span>());<span class="comment">//获取月份0～11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">getFullYear</span>());<span class="comment">//获取年份</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">getDay</span>());<span class="comment">//获取一星期中第几天0～6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">getHours</span>());<span class="comment">//获取小时0～23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">getMinutes</span>());<span class="comment">//获取分钟0～59</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">getSeconds</span>());<span class="comment">//获取秒数0～59</span></span><br><span class="line">now.<span class="title function_">getMilliseconds</span>(); <span class="comment">// 毫秒数</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>()<span class="comment">//传入字符串使用实际月份01~12，转换为Date对象后getMonth()获取的月份值为0~11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">toDateString</span>());<span class="comment">//星期几 月 日 年</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">toTimeString</span>());<span class="comment">//时 分 秒 时区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用</span></span><br><span class="line">now.<span class="title function_">toLocaleDateString</span>()</span><br><span class="line">now.<span class="title function_">toLocaleTimeString</span>()</span><br><span class="line">now.<span class="title function_">toLocaleString</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间戳 1970年头到现在的毫秒数</span></span><br><span class="line"><span class="comment">//获取总毫秒数 4种方法</span></span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//获取系统当前时间；</span></span><br><span class="line">now.<span class="title function_">getTime</span>(); <span class="comment">// [1] 1435146562875, 以number形式表示的时间戳</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="keyword">new</span> <span class="title class_">Date</span>())<span class="comment">//[2]</span></span><br><span class="line"><span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();<span class="comment">//[3] HTML5中提供的方法，有兼容性问题</span></span><br><span class="line"><span class="comment">//无需实例化 但是只能得到当前的时间戳， 而前面两种可以返回指定时间的时间戳</span></span><br><span class="line">date.<span class="title function_">valueOf</span>() <span class="comment">//[4]</span></span><br></pre></td></tr></table></figure>
<h2 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h2><blockquote>
<p>Array.from() 接收第一个参数必须是类数组对象（Array-like Object）或可迭代对象（Iterable）。Array.from() 根据 length 创建对应长度的数组。</p>
</blockquote>
<ul>
<li>类数组对象（Array-like Object）定义：拥有 length 属性的普通对象。可以没值，必须有length 属性。但没有数组方法（如 push 或 pop 、map、forEach等）。</li>
<li>常见的类数组对象<br>arguments 对象（在函数内部）<br>DOM 查询结果（如 document.querySelectorAll() 返回的 NodeList）<br>NodeList 和 HTMLCollection（例如 getElementsByTagName() 和 getElementsByClassName() 返回的集合）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;<span class="comment">//“类数组对象”的最简形式。</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;); </span><br><span class="line"><span class="comment">// 相当于 Array.from([undefined, undefined, undefined])</span></span><br><span class="line"><span class="comment">// 输出: [undefined, undefined, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> i);<span class="comment">//[0,1,2]</span></span><br></pre></td></tr></table></figure>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><ul>
<li>定义：arguments 是函数内部内置的伪数组变量，包含调用函数传入的所有实参。参数不固定用arguments。只在函数内部起作用。arguments.length 判断参数个数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x = &#x27;</span> + x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;arg &#x27;</span> + i + <span class="string">&#x27; = &#x27;</span> + <span class="variable language_">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><ul>
<li>定义：表示异步操作最终完成或失败的对象”<br>Promise.all：当所有任务必须成功才能继续。任意失败直接进入.catch 对比.any<br>Promise.allSettled：逐个处理结果，即使有失败也要拿到全部结果，比如上传多个文件、表单批量验证等场景。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抛出结果包含成功和失败的</span></span><br><span class="line">[</span><br><span class="line">  &#123; <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">value</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: <span class="string">&#x27;失败了&#x27;</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span></span><br><span class="line"> ├── 创建：<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;...&#125;)</span><br><span class="line"> ├── 成功：.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;...&#125;)</span><br><span class="line"> ├── 失败：.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;...&#125;)</span><br><span class="line"> ├── 最终：.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;...&#125;)</span><br><span class="line"> └── 链式：<span class="keyword">return</span> 值 → 下一个 then 接收</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步任务执行</span></span><br><span class="line">  <span class="keyword">if</span> (成功条件) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(结果);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(错误);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式调用</span></span><br><span class="line"><span class="comment">//每个 .then() 返回的值会传给下一个 .then()</span></span><br><span class="line"><span class="comment">//如果在 then() 里 return 一个新的 Promise，等待它完成后再进入下一个 then</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第一步：&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;第二步数据&quot;</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第二步：&quot;</span>, result);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;发生错误！&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功：&quot;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;捕获到错误：&quot;</span>, error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;中间爆炸&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;统一处理：&quot;</span>, err.<span class="property">message</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//finally</span></span><br><span class="line"><span class="title function_">doSomething</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error))</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;清理资源、结束&quot;</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>关于promise输出题规则总结：<a target="_blank" rel="noopener" href="https://wyoyo.blog.csdn.net/article/details/147492010?fromshare=blogdetail&sharetype=blogdetail&sharerId=147492010&sharerefer=PC&sharesource=qq_41775119&sharefrom=from_link">见代码输出专题</a></li>
</ul>
<h1 id="函数进阶-this-闭包"><a href="#函数进阶-this-闭包" class="headerlink" title="函数进阶 + this + 闭包"></a>函数进阶 + this + 闭包</h1><ul>
<li>柯里化：<a target="_blank" rel="noopener" href="https://wyoyo.blog.csdn.net/article/details/148389514?fromshare=blogdetail&sharetype=blogdetail&sharerId=148389514&sharerefer=PC&sharesource=qq_41775119&sharefrom=from_link">点击跳转专题</a></li>
</ul>
<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/1d97dc74699f428384fc86cfbbe08d97.png" alt="在这里插入图片描述"><br>普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined。</p>
<ul>
<li>改变this指向的方法<ul>
<li>共同点 : 都可以改变this指向</li>
<li>不同点:<ul>
<li>call 和 apply  会调用函数, 并且改变函数内部this指向.</li>
<li>call 和 apply传递的参数不一样,call传递参数使用逗号隔开，apply使用数组传递</li>
<li>bind  不会调用函数, 可以改变函数内部this指向.</li>
</ul>
</li>
<li>应用场景<ol>
<li>call 经常做继承. </li>
<li>apply常跟数组有关系.  比如借助于数学对象实现数组最大值最小值</li>
<li>bind  不调用函数,但是能改变this指向. 比如改变定时器内部的this指向.</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;andy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(a+b)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>)<span class="comment">// 此时的this指向的是window 运行结果为3</span></span><br><span class="line">fn.<span class="title function_">call</span>(o,<span class="number">1</span>,<span class="number">2</span>)<span class="comment">//此时的this指向的是对象o,参数使用逗号隔开,运行结果为3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;andy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(a+b)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>)<span class="comment">// 此时的this指向的是window 运行结果为3</span></span><br><span class="line">fn.<span class="title function_">apply</span>(o,[<span class="number">1</span>,<span class="number">2</span>])<span class="comment">//此时的this指向的是对象o,参数使用数组传递 运行结果为3</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> o = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;andy&#x27;</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = fn.<span class="title function_">bind</span>(o, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//此处的f是bind返回的新函数</span></span><br><span class="line"><span class="title function_">f</span>();<span class="comment">//调用新函数  this指向的是对象o 参数使用逗号隔开</span></span><br></pre></td></tr></table></figure>
<p>连续多个 bind，最后this指向是什么？<br>在 JavaScript 中，连续多次调用 bind 方法，最终函数的 this 上下文是由第一次调用 bind 方法的参数决定的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj1&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj3&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn1 = getName.<span class="title function_">bind</span>(obj1).<span class="title function_">bind</span>(obj2).<span class="title function_">bind</span>(obj3);</span><br><span class="line"><span class="title function_">fn1</span>(); <span class="comment">// 输出 &quot;obj1&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>特殊的this指向</li>
</ul>
<ol>
<li><code>array.forEach(function(currentValue, index, arr), thisValue)</code>forEach方法有两个参数，第一个是回调函数，第二个是 this 指向的对象，第二个参数没有传入，默认为 undefined，输出全局对象。<br>除了forEach方法，需要传入 this 指向的函数还有：every()、find()、findIndex()、map()、some()</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">arr</span>: [<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">arr</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">//window</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>IIFE立即执行函数表达式<br>立即执行函数就是定义后立刻调用的匿名函数。立即执行函数作为匿名函数，直接调用， this 就是默认全局对象 window。</li>
<li>setTimeout 和 setInterval<br>setTimeout 和 setInterval 中函数的 this 指向规则是一样的。延时效果（setTimeout）和定时效果（setInterval）都是在全局作用域下实现的。无论是 setTimeout 还是 setInterval 里传入的函数，函数中 this 的值自动指向 window。</li>
</ol>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ul>
<li>定义：接受函数作为参数or把函数作为结果值返回。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 函数表达式：把函数当值赋值给变量</span></span><br><span class="line"><span class="keyword">let</span> counter=<span class="keyword">function</span>(<span class="params">x,y</span>)&#123;<span class="keyword">return</span> x+y&#125;</span><br><span class="line"><span class="comment">//2 回调函数：把函数作为参数传递给另外一个函数 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;<span class="comment">//reduce降维</span></span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3 函数作参数 回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">	callback&amp;&amp;<span class="title function_">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;<span class="title function_">alert</span>(<span class="string">&#x27;h1&#x27;</span>)&#125;)</span><br></pre></td></tr></table></figure>
<p>如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数.<br>调用lazy_sum()时，返回的并不是求和结果，而是求和函数.调用函数f时，才真正计算求和的结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数表达式：把函数当值赋值给变量</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">lazy_sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// function sum()</span></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>在函数lazy_sum中又定义了函数sum，并且内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”<br>注意：当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数</p>
<h2 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包 (closure)"></a>闭包 (closure)</h2><ul>
<li>定义：被包的函数，有权访问其外一层作用域的变量。返回一个子函数，子函数能访问父函数的局部变量</li>
<li>优点：● 数据私有化：避免变量污染，变量作用域延伸，提高代码安全性。● 维持状态：在多次执行时保持变量值，例如防抖、节流。</li>
<li>缺点：可能导致内存泄漏， 由于闭包引用外部变量，可能导致垃圾回收机制无法回收。（手动，在不需要时手动置 element &#x3D; null）</li>
<li>应用：常见异步（定时器、事件监听、Ajax）、防抖、节流、Vue 响应式、React Hooks</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>; <span class="comment">// timer 变量用于存储定时器 ID，实现私有化</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 返回一个闭包，保持对 timer 变量的访问</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span>, args = <span class="variable language_">arguments</span>; <span class="comment">// 保存 this 上下文和参数</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123; <span class="comment">// 如果已有定时器，则清除</span></span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 设置新的定时器</span></span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args); <span class="comment">// 延迟执行目标函数</span></span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">● timer 变量在 debounce 内部，只能被返回的函数访问，避免全局变量污染。</span></span><br><span class="line"><span class="comment">● 每次调用时 timer 保持最新状态，实现防抖效果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>; <span class="comment">// 标志位，初始为 true，可以执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>; <span class="comment">// 如果标志位为 false，直接跳出</span></span><br><span class="line">    flag = <span class="literal">false</span>; <span class="comment">// 设置为 false，阻止接下来一段时间的执行</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args); <span class="comment">// 执行原函数</span></span><br><span class="line">      flag = <span class="literal">true</span>; <span class="comment">// 恢复标志位，允许下一次执行</span></span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vue响应式原理，通过闭包+依赖收集实现响应式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123; <span class="comment">// 创建 Proxy 代理对象</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`读取 <span class="subst">$&#123;key&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> target[key]; <span class="comment">// 读取对象属性</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`更新 <span class="subst">$&#123;key&#125;</span> -&gt; <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">      target[key] = value; <span class="comment">// 更新对象属性</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line">data.<span class="property">count</span>++; <span class="comment">// 读取 count -&gt; 更新 count -&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//react hooks：useState 利用闭包存储状态。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> state = initialValue; <span class="comment">// 闭包变量 state</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setState</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    state = newValue; <span class="comment">// 更新 state</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;State updated to:&quot;</span>, state);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [<span class="function">() =&gt;</span> state, setState]; <span class="comment">// 返回 getter 和 setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [getState, setState] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getState</span>()); <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">setState</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getState</span>()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回闭包时牢记：返回函数不要引用任何循环变量，或者后续会发生变化的变量。因为 JavaScript 中的闭包会引用外部环境的变量，而这些变量值在循环结束后可能已经发生了变化。<br>  假设我们在循环中创建闭包，并将循环变量作为闭包函数的引用，最终所有闭包都会共享同一个变量的引用，并且这个变量在每次迭代时都会更新，导致闭包内部的值不是我们期望的。<ul>
<li>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确应用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 利用for循环创建了4个立即执行函数</span></span><br><span class="line"><span class="comment">// 立即执行函数成为小闭包。因为立即执行函数里任何函数都可以使用它的i这变量</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    lis[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*需求分析</span></span><br><span class="line"><span class="comment">打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格</span></span><br><span class="line"><span class="comment">如果有拥堵情况,总价格多收取10块钱拥堵费*/</span></span><br><span class="line"> <span class="keyword">var</span> car = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> start = <span class="number">13</span>; <span class="comment">// 起步价  局部变量</span></span><br><span class="line">     <span class="keyword">var</span> total = <span class="number">0</span>; <span class="comment">// 总价  局部变量</span></span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="comment">// 正常的总价</span></span><br><span class="line">       <span class="attr">price</span>: <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">           total = start;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           total = start + (n - <span class="number">3</span>) * <span class="number">5</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> total;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">// 拥堵之后的费用</span></span><br><span class="line">       <span class="attr">yd</span>: <span class="keyword">function</span>(<span class="params">flag</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> flag ? total + <span class="number">10</span> : total;</span><br><span class="line">       &#125;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="title function_">price</span>(<span class="number">5</span>)); <span class="comment">// 23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="title function_">yd</span>(<span class="literal">true</span>)); <span class="comment">// 33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误实例</span></span><br><span class="line"><span class="keyword">const</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  funcs.<span class="title function_">push</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  <span class="comment">// 打印 i 的值</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 `i` 是 `var`，它在整个函数作用域内是共享的，循环结束时 i = 3</span></span><br><span class="line">funcs[<span class="number">0</span>]();  <span class="comment">// 输出 3</span></span><br><span class="line">funcs[<span class="number">1</span>]();  <span class="comment">// 输出 3</span></span><br><span class="line">funcs[<span class="number">2</span>]();  <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用 let 来替代 var（块级作用域）</span></span><br><span class="line"><span class="comment">let 会为每个循环迭代创建一个新的作用域，因此每次循环时，闭包捕获的 i 值是当前的值，不会和后续的值产生冲突。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  funcs.<span class="title function_">push</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  <span class="comment">// 每个闭包捕获到的 `i` 是不同的</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs[<span class="number">0</span>]();  <span class="comment">// 输出 0</span></span><br><span class="line">funcs[<span class="number">1</span>]();  <span class="comment">// 输出 1</span></span><br><span class="line">funcs[<span class="number">2</span>]();  <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>
<p>没有class机制，借助闭包，同样可以封装一个私有变量<br>闭包就是携带状态的函数，并且它的状态可以完全对外隐藏<br>工厂函数，因为它像工厂一样 生产对象。每次调用工厂函数时，都会返回一个新对象，而这个对象可以包含不同的属性和方法。工厂函数用于实现对象创建和封装，尤其是在没有 class 机制的情况下，工厂函数可以帮助你模仿类的行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//闭包也可以模拟class</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;  <span class="comment">// `count` 是私有变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count--;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getCount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">createCounter</span>();</span><br><span class="line">counter.<span class="title function_">increment</span>();  <span class="comment">// 输出 1</span></span><br><span class="line">counter.<span class="title function_">increment</span>();  <span class="comment">// 输出 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="title function_">getCount</span>());  <span class="comment">// 输出 2</span></span><br><span class="line">counter.<span class="title function_">decrement</span>();  <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接访问 `count` 会出错，因为它是私有的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="property">count</span>);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<ul>
<li>闭包用于实现缓存</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">memorize</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)<span class="comment">//转换成array</span></span><br><span class="line">        <span class="keyword">var</span> key = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(args)<span class="comment">//将序列化的作为key</span></span><br><span class="line">        <span class="keyword">return</span> cache[key] || (cache[key] = fn.<span class="title function_">apply</span>(fn, args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adder = <span class="title function_">memorize</span>(add)</span><br><span class="line"><span class="title function_">adder</span>(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line"><span class="title function_">adder</span>(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line"><span class="title function_">adder</span>(<span class="number">2</span>)            <span class="comment">// 输出: 3    当前: cache: &#123; &#x27;[1]&#x27;: 2, &#x27;[2]&#x27;: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6版本</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">memorize</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;<span class="comment">//换成了扩展运算符</span></span><br><span class="line">        <span class="keyword">const</span> key = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(args)</span><br><span class="line">        <span class="keyword">return</span> cache[key] || (cache[key] = fn.<span class="title function_">apply</span>(fn, args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><ul>
<li>promise部分放在上个章节promise对象中</li>
</ul>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h2><ul>
<li>定义：基于 Promise 的语法糖，让异步代码写起来像同步代码，更清晰、可读性更好</li>
<li>与promise相比</li>
</ul>
<table>
<thead>
<tr>
<th>对比项</th>
<th><code>Promise</code> 写法</th>
<th><code>async/await</code> 写法</th>
</tr>
</thead>
<tbody><tr>
<td>可读性</td>
<td>回调链式 <code>.then().then()</code></td>
<td>像同步代码，逐行写</td>
</tr>
<tr>
<td>错误处理</td>
<td>用 <code>.catch()</code> 统一处理</td>
<td>使用 <code>try...catch</code> 更直观</td>
</tr>
<tr>
<td>执行顺序控制</td>
<td>多层嵌套或 <code>Promise.all</code> 组合</td>
<td>用 <code>await</code> 串行或组合更自然</td>
</tr>
<tr>
<td>返回值处理</td>
<td>需在 <code>.then()</code> 中拿数据</td>
<td><code>await</code> 直接拿到值</td>
</tr>
</tbody></table>
<ul>
<li>易错点</li>
</ul>
<table>
<thead>
<tr>
<th>易错点</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>❌ 顶层不能直接用 <code>await</code>（除非在模块环境）</td>
<td>需放在 async 函数中</td>
</tr>
<tr>
<td>❌ <code>await</code> 会阻塞后面代码（串行）</td>
<td>用 <code>Promise.all()</code> 并发</td>
</tr>
<tr>
<td>❌ 忘记 <code>try...catch</code> 会漏掉错误</td>
<td>可能导致异常未捕获</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">fetch</span>(...);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(...).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//async：一个函数前加 async，它就总是返回一个 Promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)); <span class="comment">// 输出 123（自动包一层 Promise.resolve(123)）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//await：用来“暂停”异步操作，等待 Promise 执行完成，并获取结果</span></span><br><span class="line"><span class="comment">//await 后面必须是一个 Promise 或类 Promise 的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/user&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> json = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/error&#x27;</span>); <span class="comment">// 失败则进入 catch</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;发生错误：&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串型 v.s. 并行</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">await</span> <span class="title function_">fetchA</span>();</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">await</span> <span class="title function_">fetchB</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">fetchA</span>(), <span class="title function_">fetchB</span>()]);</span><br></pre></td></tr></table></figure>
<h3 id="JS-的-await-与-python-的-await"><a href="#JS-的-await-与-python-的-await" class="headerlink" title="JS 的 await 与 python 的 await"></a>JS 的 await 与 python 的 await</h3><ul>
<li>JS的 await<br>JavaScript 中用于处理异步操作，它只能在 async 函数中使用，用来等待一个 Promise 完成并返回其结果。它的主要作用是让代码看起来像同步操作，但实际上仍然是异步执行。<br>简化了一堆.then()的链式调用<br>await 只会暂停当前的异步函数，而不会阻塞整个程序。<br>如果 await 后的 Promise 被拒绝（rejected），会抛出错误，需要用 try-catch 捕获。</li>
<li>python的await<br>python逻辑同理，await 允许你等待这些操作完成，而不会阻塞事件循环，使得程序可以处理其他任务。异步操作通常涉及 I&#x2F;O 密集型任务，比如：<br>网络请求（HTTP API 调用）<br>文件操作<br>数据库查询<br>计时器</li>
</ul>
<h2 id="回调函数callback"><a href="#回调函数callback" class="headerlink" title="回调函数callback"></a>回调函数callback</h2><ul>
<li>定义：回调函数就是被传入另一个函数中，在其内部“被调用”的函数。</li>
<li>应用：setTimeout&#x2F;Ajax</li>
<li>回调地狱：多个异步操作嵌套执行，导致代码层层缩进，结构混乱、难以维护。<br>解决：promise&#x2F;async&#x2F;await</li>
</ul>
<h1 id="原型-面向对象"><a href="#原型-面向对象" class="headerlink" title="原型 &amp; 面向对象"></a>原型 &amp; 面向对象</h1><ul>
<li><code>_proto__</code> v.s. prototype</li>
</ul>
<table>
<thead>
<tr>
<th>对比项</th>
<th><code>__proto__</code></th>
<th><code>prototype</code></th>
</tr>
</thead>
<tbody><tr>
<td>是谁的属性</td>
<td>所有对象的隐藏属性</td>
<td>构造函数的属性</td>
</tr>
<tr>
<td>类型</td>
<td>Object</td>
<td>Object</td>
</tr>
<tr>
<td>作用</td>
<td>指向创建它的构造函数的 <code>prototype</code> 对象</td>
<td>定义所有实例共享的属性和方法</td>
</tr>
<tr>
<td>是否参与原型链</td>
<td>✅ 是原型链实际连接通道</td>
<td>✅ 是被 <code>__proto__</code> 指向的对象</td>
</tr>
<tr>
<td>修改后影响</td>
<td>改变原型链走向</td>
<td>改变所有实例的共享内容</td>
</tr>
<tr>
<td>常用于</td>
<td>判断原型链、调试</td>
<td>添加实例公共方法、继承</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) <span class="comment">// 等价于 obj.__proto__（标准做法）</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto) <span class="comment">// 设置 __proto__</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(proto) <span class="comment">// 创建一个指定原型的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6 class</span></span><br></pre></td></tr></table></figure>
<h2 id="原型-原型链-Prototype-Chain"><a href="#原型-原型链-Prototype-Chain" class="headerlink" title="原型+原型链 Prototype Chain"></a>原型+原型链 Prototype Chain</h2><ul>
<li>定义<br>【原型（对象）prototype】原型是JavaScript 中所有对象都有的内置属性。原型是对象，又称原型对象，可以提供方法和属性，供其他对象继承和使用。每个 JavaScript 对象都有一个内部属性 [[Prototype]]（通常可以通过 <code>__proto__ </code>或 <code>Object.getPrototypeOf(obj)</code> 来访问）。这个属性指向了该对象的原型。Object.prototype 是所有对象的原型链的终点，Object.prototype 是所有对象的原型。<br>【原型链（Prototype Chain）】<br>JavaScript 对象的原型链是由多个对象<code>__proto__</code>串起的链式结构。访问属性时，JavaScript 首先查找该对象自身是否具有这个属性。如果没有找到，它会继续查找该对象原型，直到查找到 Object.prototype 为止。如果在 Object.prototype 也没有找到，那么会返回 undefined。<br>【构造函数 constructor】prototype 对象默认有 constructor 属性，指向其关联的构造函数，constructor 属性可以用于创建新的实例。<br>【function.prototype】构造函数的属性（普通对象没有prototype），指向其原型（对象），&#x3D;&#x3D;修改prototype需要手动修正constructor，否则 constructor 指向错误对象。&#x3D;&#x3D;<br>【<code>.__proto__ </code>】对象的属性（所有对象，函数也是对象），指向其构造函数的原型，即创建这个对象的构造函数的 prototype，即<code>let dog = new Animal(&#39;Buddy&#39;); dog.__proto__ === Animal.prototype，dog的原型是Animal.prototype</code>，是实例对象的“继承指针”，用于原型链查找路径，向上查找，原型链终止于null；目前用<code>Object.getPrototypeOf()/ Object.setPrototypeOf()</code>替代<blockquote>
<p>构造函数的原型对象的constructor属性指向构造函数,实例对象的原型的constructor属性也指向了构造函数。</p>
</blockquote>
</li>
<li>作用<br>实现继承，共享属性和方法。方法只需要在构造函数原型上定义一次，所有它的实例都会通过原型链访问这个方法。节省内存，增加复用。</li>
<li>原型链的性能问题：原型链越长，查找属性的时间越长。<br>优化：<br>○ 避免过深的继承层次。<br>○ 使用 hasOwnProperty() 判断对象是否有自己的属性。<br>○ 缓存查找结果，减少重复查找。</li>
<li>Object.create(null) 创建的对象没有原型、没有继承来的方法属性，是纯净对象</li>
<li>&#x3D;&#x3D;重写原型（直接赋值对象）之后其构造函数指向object，需要修复回来&#x3D;&#x3D;</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Animal.prototype 是 Animal 构造函数的原型对象，</span></span><br><span class="line"><span class="comment">默认有 constructor 属性，指向 Animal 本身。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// &#123; constructor: ƒ Animal() &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Animal</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">constructor</span> === <span class="title class_">Animal</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">__proto__</span> === <span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;<span class="comment">//重写原型</span></span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Animal</span>, <span class="comment">// 手动修正 constructor!!</span></span><br><span class="line">  <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//或者这样修正 Animal.prototype.constructor=Animal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Buddy&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">constructor</span> === <span class="title class_">Animal</span>); <span class="comment">// true </span></span><br><span class="line"><span class="comment">//如果没有constructor设置，则得到dog.constructor ===Object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">//修改原型</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">__proto__</span>,<span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>,child.<span class="property">__proto__</span> === <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">//Child &#123;&#125; Child &#123;&#125; true 都指向new Parent()得到的对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>,<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>,<span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br><span class="line"><span class="comment">//&#123; greet: [Function (anonymous)] &#125; &#123; greet: [Function (anonymous)] &#125; true</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/092d4b3982b14af39a42765c5e1174fd.png" alt="在这里插入图片描述"></p>
<ul>
<li>扩展内置方法<br>通过 Array.prototype.xxx &#x3D; function(){} 的方式，避免覆盖其原型其他内容</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sum</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  	sum += <span class="variable language_">this</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="instance原理"><a href="#instance原理" class="headerlink" title="instance原理"></a>instance原理</h2><ul>
<li>定义<br><code>object instanceof Constructor</code>返回true&#x2F;false</li>
<li>作用<br>instanceof 用于检查构造函数的 prototype 是否出现在对象原型链上</li>
<li>原理+手写<br>instanceof 通过遍历 object 的原型链，检查 构造函数原型Constructor.prototype 是否存在于其中。<br>● 详细步骤：<br>a. 取 object 的<code> __proto__</code>（即 Object.getPrototypeOf(object)）。<br>b. 依次向上查找原型链，直到找到 Constructor.prototype，返回 true。<br>c. 如果原型链查找到 null 仍未匹配，则返回 false。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceOf</span>(<span class="params">obj, constructor</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取 obj 的原型，即 __proto__</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历原型链，直到找到匹配的 prototype 或者到达原型链的尽头</span></span><br><span class="line">  <span class="keyword">while</span> (proto) &#123;</span><br><span class="line">    <span class="comment">// 如果当前原型与 constructor.prototype 相等，则返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (proto === constructor.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继续沿着原型链向上查找</span></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果遍历完整个原型链仍未找到匹配的 prototype，则返回 false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>缺点+解决</li>
</ul>
<ol>
<li>仅适用于引用类型， instanceof 不能检查基本数据类型，必返回false。因为基本数据类型不是对象，它们没有原型链。<blockquote>
<p>如何判断 null 和 undefined 是否是某个构造函数的实例？都不是，用typeof可以得到</p>
</blockquote>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>        <span class="comment">// &quot;object&quot;（历史遗留bug）</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>   <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>原型链过深影响性能</li>
<li>Object.create(null) 创建的对象没有原型和原型链，因此 instanceof 对其无效。<br>解决：使用 Symbol.hasInstance 自定义 instanceof 逻辑， JavaScript 允许使用 Symbol.hasInstance 修改 instanceof 的行为。<br>JavaScript 设计了一些 “内置符号（well-known symbols）”，“钩子式”地自定义 JS 行为。[Symbol.hasInstance] 是其中之一（Symbol）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行 obj instanceof CustomClass 时</span></span><br><span class="line"><span class="comment">其实内部执行的是 CustomClass[Symbol.hasInstance](obj)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> instance.<span class="property">customProperty</span> === <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">customProperty</span>: <span class="literal">true</span> &#125;;<span class="comment">//给这个对象手动设置判断自定义原型的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">CustomClass</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对比<br>1）instanceof 与  obj.constructor 属性对比：constructor 可能修改。<br>2）instanceof 与 Object.prototype.toString.call 对比：基本数据类型，使用 Object.prototype.toString.call 更加可靠</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog <span class="keyword">instanceof</span> <span class="title class_">Dog</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog <span class="keyword">instanceof</span> <span class="title class_">Animal</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog <span class="keyword">instanceof</span> <span class="title class_">Object</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//class 本质上是语法糖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手写继承"><a href="#手写继承" class="headerlink" title="手写继承"></a>手写继承</h2><table>
<thead>
<tr>
<th>继承方式</th>
<th>说明</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>1. 原型链继承</td>
<td>子类型的原型指向父类型实例</td>
<td>简单，实例共享父原型属性和方法</td>
<td>父类型引用属性会被所有子类共享</td>
</tr>
<tr>
<td>2. 借用构造函数继承</td>
<td>在子构造函数中调用父构造函数</td>
<td>解决引用类型共享问题</td>
<td>每个实例都有父构造函数副本，方法不能复用</td>
</tr>
<tr>
<td>3. 组合继承</td>
<td>结合原型链继承和借用构造函数</td>
<td>既能继承实例属性，又能继承原型方法</td>
<td>父构造函数调用两次，略有冗余</td>
</tr>
<tr>
<td>4. 原型式继承</td>
<td>使用 <code>Object.create()</code> 创建新对象</td>
<td>简单，灵活</td>
<td>方法共享，属性引用共享问题</td>
</tr>
<tr>
<td>5. 寄生式继承</td>
<td>在原型式继承基础上增强对象</td>
<td>灵活，扩展方便</td>
<td>方法共享，性能不佳</td>
</tr>
<tr>
<td>6. 寄生组合继承</td>
<td>组合继承的优化版本</td>
<td>高效，避免调用两次父构造函数</td>
<td>复杂一点，需要辅助函数</td>
</tr>
<tr>
<td>7. ES6 class 继承</td>
<td>使用 <code>class</code> 和 <code>extends</code> 语法</td>
<td>语法简洁，符合面向对象风格</td>
<td>依赖现代环境，语法糖本质还是原型继承</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手写继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Animal&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name, breed</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在子类的构造函数中，手动调用了父类构造函数 Animal，</span></span><br><span class="line"><span class="comment">并将当前子类实例（this）作为上下文传入,传入name参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//指定原型</span></span><br><span class="line"><span class="comment">//新创建的对象的__proto__直接指向这个参数</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Buddy&#x27;</span>, <span class="string">&#x27;Labrador&#x27;</span>);</span><br><span class="line">dog.<span class="title function_">sayHello</span>(); <span class="comment">// Hello from Animal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原型链继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">property</span>=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getValue</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subProperty</span>=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">let</span> instance=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//借用构造函数继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">property</span>=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">property</span>=<span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span>=[<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;purple&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getPro</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">property,name</span>)&#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,property);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//原型继承</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line"> friends : [<span class="string">&quot;yuki&quot;</span>,<span class="string">&quot;sakura&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Object</span>.<span class="title function_">create</span>(a);</span><br><span class="line">b.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;ruby&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="title class_">Object</span>.<span class="title function_">create</span>(a);</span><br><span class="line">c.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lemon&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(a.<span class="property">friends</span>);<span class="comment">//&quot;yuki,sakura,ruby,lemon&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//寄生式继承,可以类比设计模式的工厂模式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">obj</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> clone = <span class="title function_">object</span>(obj);</span><br><span class="line"> clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寄生组合式继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span>=[<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;white&#x27;</span>,<span class="string">&#x27;gray&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span>=<span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name);<span class="comment">//第二次调用Parent()</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span>=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title class_">Parent</span>()<span class="comment">//第一次调用Parent()</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>=<span class="title class_">Son</span>;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAge</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>()&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span>()&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>call()<br>ES6之前没有提供 extends 继承。可以通过构造函数+原型对象模拟实现继承，被称为组合继承。<br>call()可以调用函数<br>call()可以修改this的指向,使用call()的时候 参数一是修改后的this指向,参数2,参数3..使用逗号隔开连接</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;</span><br><span class="line">  	<span class="attr">name</span>: <span class="string">&#x27;andy&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  fn.<span class="title function_">call</span>(o, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//调用函数此时的this指向了对象o,输出3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子构造函数继承父构造函数中的属性</span></span><br><span class="line"> <span class="comment">// 1. 父构造函数</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">   <span class="comment">// this 指向父构造函数的对象实例</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">// 2 .子构造函数 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">uname, age, score</span>) &#123;</span><br><span class="line">  <span class="comment">// this 指向子构造函数的对象实例</span></span><br><span class="line">  <span class="comment">//3.使用call方式实现子继承父的属性</span></span><br><span class="line">  <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, uname, age);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">score</span> = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son);</span><br><span class="line"></span><br><span class="line"><span class="comment">//借用原型对象继承方法</span></span><br><span class="line"><span class="comment">// 1. 父构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">  <span class="comment">// this 指向父构造函数的对象实例</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">money</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">100000</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">// 2 .子构造函数 </span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">uname, age, score</span>) &#123;</span><br><span class="line">      <span class="comment">// this 指向子构造函数的对象实例</span></span><br><span class="line">      <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, uname, age);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">score</span> = score;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// Son.prototype = Father.prototype;  </span></span><br><span class="line"><span class="comment">//这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化</span></span><br><span class="line">  <span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"><span class="comment">//本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</span></span><br><span class="line">  <span class="comment">// 如果利用对象形式重写原型对象,别忘了利用constructor 指回原来的构造函数</span></span><br><span class="line">  <span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Son</span>;</span><br><span class="line">  <span class="comment">// 这个是子构造函数专门的方法</span></span><br><span class="line">  <span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">exam</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;孩子要考试&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(son);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数也是一个对象，它的原型链是：</span><br><span class="line">foo ----&gt; <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> ----&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> ----&gt; <span class="literal">null</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>定义<span class="title function_">apply</span>()等方法，所有函数都可以调用<span class="title function_">apply</span>()方法</span><br></pre></td></tr></table></figure>
<p>基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">PrimaryStudent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用Student构造函数，绑定this变量:</span></span><br><span class="line">    <span class="title class_">Student</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">grade</span> = props.<span class="property">grade</span> || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">但是，调用了<span class="title class_">Student</span>构造函数不等于继承了<span class="title class_">Student</span></span><br><span class="line"><span class="title class_">PrimaryStudent</span>的原型链是：</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">PrimaryStudent</span>() ----&gt; <span class="title class_">PrimaryStudent</span>.<span class="property"><span class="keyword">prototype</span></span> ----&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> ----&gt; <span class="literal">null</span></span><br><span class="line">必须想办法把原型链修改为：</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">PrimaryStudent</span>() ----&gt; <span class="title class_">PrimaryStudent</span>.<span class="property"><span class="keyword">prototype</span></span> ----&gt; <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> ----&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> ----&gt; <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//简单粗暴的方法 即</span></span><br><span class="line"><span class="title class_">PrimaryStudent</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="comment">//定义这个PrimaryStudent没有意义</span></span><br><span class="line"><span class="comment">//必须借助一个中间对象来实现正确的原型链，</span></span><br><span class="line"><span class="comment">//中间对象的原型要指向Student.prototype</span></span><br><span class="line"><span class="comment">//中间对象可用一个空函数F来实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空函数F:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把F的原型指向Student.prototype:</span></span><br><span class="line">F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:</span></span><br><span class="line"><span class="title class_">PrimaryStudent</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:</span></span><br><span class="line"><span class="title class_">PrimaryStudent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">PrimaryStudent</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：</span></span><br><span class="line"><span class="title class_">PrimaryStudent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getGrade</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">grade</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建xiaoming:</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> <span class="title class_">PrimaryStudent</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">grade</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">xiaoming.<span class="property">name</span>; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaoming.<span class="property">grade</span>; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证原型:</span></span><br><span class="line">xiaoming.<span class="property">__proto__</span> === <span class="title class_">PrimaryStudent</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line">xiaoming.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证继承关系:</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> <span class="title class_">PrimaryStudent</span>; <span class="comment">// true</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> <span class="title class_">Student</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数F仅用于桥接，仅创建了一个new F()实例，但并不在原型链中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把继承用inherits()函数封装，隐藏F定义，能复用并简化代码：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inherits</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">    <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现原型继承链:</span></span><br><span class="line"><span class="title function_">inherits</span>(<span class="title class_">PrimaryStudent</span>, <span class="title class_">Student</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定其他方法到PrimaryStudent原型:</span></span><br><span class="line"><span class="title class_">PrimaryStudent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getGrade</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">grade</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>JavaScript 原型继承实现方式：</p>
<ol>
<li>定义新的构造函数，并在内部用call()调用“继承”的构造函数，并绑定this；</li>
<li>借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；  修复子对象的constructor指向</li>
<li>继续在新的构造函数的原型上定义新方法。</li>
</ol>
<h1 id="浏览器-API"><a href="#浏览器-API" class="headerlink" title="浏览器 API"></a>浏览器 API</h1><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API">官方文档点击跳转</a></p>
<h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><p><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/5b02002bdb2e4992944e23f4a8403663.png" alt="在这里插入图片描述"><br>解析（Parser）HTML，生成DOM树(DOM Tree)<br>同时解析（Parser） CSS，生成样式规则 (Style Rules)<br>根据DOM树和样式规则，生成渲染树(Render Tree)<br>进行布局 Layout(回流&#x2F;重排):根据生成的渲染树，得到节点的几何信息（位置，大小）<br>进行绘制 Painting(重绘): 根据计算和获取的信息进行整个页面的绘制<br>Display: 展示在页面上</p>
<ul>
<li>回流(重排)<br>当 Render Tree 中部分或者全部元素的尺寸、结构、布局等发生改变时，浏览器就会重新渲染部分或全部文档的过程称为回流。<br>会导致回流（重排）的操作：影响到布局就会有回流<br> 页面的首次刷新<br> 浏览器的窗口大小发生改变<br> 元素的大小或位置发生改变<br> 改变字体的大小<br> 内容的变化（如：input框的输入，图片的大小）<br> 激活css伪类 （如：:hover）<br> 脚本操作DOM（添加或者删除可见的DOM元素）</li>
<li>重绘<br>由于节点(元素)的样式的改变并不影响它在文档流中的位置和文档布局时(比如：color、background-color、outline等), 称为重绘。</li>
<li>重绘不一定引起回流，而回流一定会引起重绘。<br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/59b00cc0b9e94804af06130dc9c915f3.png" alt="在这里插入图片描述"></li>
</ul>
<h2 id="DOM-（Document-Object-Model）"><a href="#DOM-（Document-Object-Model）" class="headerlink" title="DOM （Document Object Model）"></a>DOM （Document Object Model）</h2><ul>
<li>定义：文档对象模型，是 HTML&#x2F;XML 文档结构化表现，表示页面内容和结构。是浏览器提供的 API，允许 JS 操作网页内容。<br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/52415a23fcdf40ef8ac6572a815e93e5.png" alt="在这里插入图片描述"></li>
<li>包括：<br>DOM树：节点树（元素节点、文本节点、属性节点等）<br>常用对象：<br>document  顶层对象 整个文档入口<br>Element、HTMLElement — 页面元素<br>节点操作方法<br>事件相关接口<blockquote>
<p>节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。<br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/712a02b7e675493ea4ecf7e62616ab8b.png" alt="在这里插入图片描述"></p>
</blockquote>
</li>
<li>使用<ul>
<li>三种动态创建元素的区别</li>
</ul>
</li>
</ul>
<ol>
<li>document.write 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘</li>
<li>innerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘； 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂；innerHTML 复制节点的时候，不会复制原先节点的事件，会存在内存泄露问题</li>
<li>createElement() 创建多个元素效率稍低，但是结构更清晰，如果页面创建元素较少，建议使用 createElement()<br>总结：不同浏览器下，innerHTML 效率要比 creatElement 高</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取特殊元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span> <span class="comment">//body元素对象</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span> <span class="comment">//html元素对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myId&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> elems = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;myClass&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> elems = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> elem = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.myClass&#x27;</span>);<span class="comment">//匹配第一个</span></span><br><span class="line"><span class="keyword">const</span> elems = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.myClass&#x27;</span>);<span class="comment">//匹配所有，数组</span></span><br><span class="line"><span class="keyword">var</span> j_tbs = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;j_tb&#x27;</span>).<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;input&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//利用节点操作获取元素</span></span><br><span class="line"><span class="comment">// 父(parentNode)、子(children)、兄(previousElementSibling、nextElementSibling) </span></span><br><span class="line"><span class="comment">//父级节点 返回最近的一个父节点或者null</span></span><br><span class="line">node.<span class="property">parentNode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回包含指定节点的子节点的集合，该集合为即时更新的集合。</span></span><br><span class="line"><span class="comment">//包含了所有的子节点，包括元素节点，文本节点等。</span></span><br><span class="line"><span class="comment">//如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes</span></span><br><span class="line">parentNode.<span class="property">childNodes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回</span></span><br><span class="line"><span class="comment">//是得到了各个浏览器的支持</span></span><br><span class="line">parentNode.<span class="property">children</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个或最后一个 找不到则返回null。同样，也是包含所有的节点。</span></span><br><span class="line"><span class="comment">//子节点 不仅仅是元素节点</span></span><br><span class="line">parentNode.<span class="property">firstChild</span></span><br><span class="line">parentNode.<span class="property">lastChild</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第一个子元素节点，找不到则返回null。</span></span><br><span class="line"><span class="comment">//注意：这两个方法有兼容性问题，IE9 以上才支持。</span></span><br><span class="line">parentNode.<span class="property">firstElementChild</span></span><br><span class="line">parentNode.<span class="property">lastElementChild</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//综上</span></span><br><span class="line"><span class="comment">//firstChild 和 lastChild 包含其他节点，操作不方便</span></span><br><span class="line"><span class="comment">//firstElementChild 和lastElementChild 又有兼容性问题</span></span><br><span class="line"><span class="comment">//如果要第一个子元素节点，使用 parentNode.chilren[0]</span></span><br><span class="line"><span class="comment">//如果是最后一个子元素节点，使用 parentNode.chilren[parentNode.chilren.length - 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//兄弟节点 返回当前元素的下一个兄弟节点，找不到则返回null。包含所有的节点。</span></span><br><span class="line">node.<span class="property">nextSibling</span></span><br><span class="line">node.<span class="property">previousSibling</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//兄弟元素节点 注意：这两个方法有兼容性问题， IE9 以上才支持。</span></span><br><span class="line">node.<span class="property">nextElementSibling</span></span><br><span class="line">node.<span class="property">previousElementSibling</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自己封装的获取兄弟节点函数 同时解决兼容性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getNextElementSibling</span>(<span class="params">element</span>) &#123;</span><br><span class="line">	 <span class="keyword">var</span> el = element;</span><br><span class="line">	 <span class="keyword">while</span> (el = el.<span class="property">nextSibling</span>) &#123;</span><br><span class="line">		 <span class="keyword">if</span> (el.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">		 	<span class="keyword">return</span> el;</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node.<span class="title function_">cloneNode</span>()<span class="comment">//返回调用该方法的节点的一个副本。</span></span><br><span class="line"><span class="comment">//如果括号参数为空或者为 false ，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点。</span></span><br><span class="line"><span class="comment">//如果括号参数为 true ，则是深度拷贝，会复制节点本身以及里面所有的子节点。</span></span><br><span class="line"></span><br><span class="line">parentNode.<span class="title function_">replaceChild</span>(newChild, oldChild);</span><br><span class="line"><span class="comment">//用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增删改查</span></span><br><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">write</span></span><br><span class="line">innerHTML</span><br><span class="line"></span><br><span class="line">parentElem.<span class="title function_">appendChild</span>(div);          <span class="comment">// 添加到子元素最后</span></span><br><span class="line">parentElem.<span class="title function_">insertBefore</span>(div, refElem); <span class="comment">// 插入到指定元素之前</span></span><br><span class="line"></span><br><span class="line">parentElem.<span class="title function_">removeChild</span>(childElem);</span><br><span class="line"><span class="comment">//注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。</span></span><br><span class="line"><span class="comment">//当你遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。</span></span><br><span class="line">parent.<span class="title function_">removeChild</span>(parent.<span class="property">children</span>[<span class="number">0</span>]);</span><br><span class="line">parent.<span class="title function_">removeChild</span>(parent.<span class="property">children</span>[<span class="number">1</span>]); <span class="comment">// &lt;-- 浏览器报错</span></span><br><span class="line"><span class="comment">//因为一共有0，1两号子节点，删掉0号后1号自动变0号</span></span><br><span class="line">childElem.<span class="title function_">remove</span>(); <span class="comment">// 现代浏览器支持</span></span><br><span class="line"></span><br><span class="line">elem.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;p&gt;新内容&lt;/p&gt;&#x27;</span>; <span class="comment">// 插入HTML内容（支持标签）</span></span><br><span class="line">elem.<span class="property">textContent</span> = <span class="string">&#x27;纯文本内容&#x27;</span>;   <span class="comment">// 插入纯文本（安全）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">修改元素属性： src、href、title等</span></span><br><span class="line"><span class="comment">修改普通元素内容： innerHTML 、innerText</span></span><br><span class="line"><span class="comment">安全起见，尽量使用innerText</span></span><br><span class="line"><span class="comment">修改表单元素： value、type、disabled、checked,selected等</span></span><br><span class="line"><span class="comment">修改元素样式： style、className</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//样式属性</span></span><br><span class="line"><span class="comment">//样式名字带-的改成驼峰命名 因为在js中会被解析成减法</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">backgroundImage</span> = <span class="string">&#x27;url(&#x27;</span> + <span class="variable language_">this</span>.<span class="property">src</span> + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">element.<span class="property">className</span><span class="comment">//覆盖原先类名 class是关键字不能用</span></span><br><span class="line">element.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;class1&quot;</span>, <span class="string">&quot;class2&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.tab .active&#x27;</span>).<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">.<span class="title function_">remove</span>(class1,class2,..);</span><br><span class="line">.<span class="title function_">toggle</span>(<span class="keyword">class</span>)<span class="comment">//切换（添加或移除）指定的 CSS 类。如果该类已存在，则移除它；如果不存在，则添加它。</span></span><br><span class="line"></span><br><span class="line">elem.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-id&#x27;</span>, <span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">elem.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-id&#x27;</span>);</span><br><span class="line">elem.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;data-id&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作类名</span></span><br><span class="line">elem.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>);      <span class="comment">// 添加类</span></span><br><span class="line">elem.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;active&#x27;</span>);   <span class="comment">// 移除类</span></span><br><span class="line">elem.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;active&#x27;</span>);   <span class="comment">// 有则移除，无则添加</span></span><br><span class="line">elem.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;active&#x27;</span>); <span class="comment">// 是否包含该类，返回布尔</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//事件绑定</span></span><br><span class="line">elem.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//前面要加on</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击了&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">elem.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击了&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">elem.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler);</span><br><span class="line">elem.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler);</span><br></pre></td></tr></table></figure>
<p><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/99b5e89fe05a40f1ba709be9ee642296.png" alt="在这里插入图片描述"></p>
<ul>
<li>scroll【区分页面&#x2F;元素】<br>⚠️ 注意：只有<code>overflow: scroll|auto</code>才能滚动，才有 scrollTop</li>
</ul>
<ol>
<li>页面被卷去的头部：可以通过window.pageYOffset 获得  如果是被卷去的左侧window.pageXOffset</li>
<li>注意，元素被卷去的头部是element.scrollTop  , 如果是页面被卷去的头部 则是 window.pageYOffset<br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/f1931051a36b43ec8bc5f7d08654ec96.png" alt="在这里插入图片描述"></li>
</ol>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>element.scrollTop</code></td>
<td>元素垂直方向滚动的像素值（从顶部开始）</td>
</tr>
<tr>
<td><code>element.scrollLeft</code></td>
<td>元素水平方向滚动的像素值（从左边开始）</td>
</tr>
<tr>
<td><code>element.scrollHeight</code></td>
<td>元素内容实际高度（包括看不见的部分）</td>
</tr>
<tr>
<td><code>element.scrollWidth</code></td>
<td>元素内容实际宽度</td>
</tr>
<tr>
<td><code>window.scrollY</code></td>
<td>垂直方向滚动的距离（别名：<code>pageYOffset</code>）</td>
</tr>
<tr>
<td><code>window.scrollX</code></td>
<td>水平方向滚动的距离</td>
</tr>
<tr>
<td><code>window.scrollTo(x, y)</code></td>
<td>滚动到指定位置</td>
</tr>
<tr>
<td><code>window.scrollBy(x, y)</code></td>
<td>相对当前位置滚动</td>
</tr>
</tbody></table>
<p>区别：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属于谁</th>
<th>用途</th>
<th>是否可写</th>
</tr>
</thead>
<tbody><tr>
<td><code>scrollTop</code></td>
<td>DOM 元素</td>
<td>元素垂直滚动条位置</td>
<td>✅ 可读写</td>
</tr>
<tr>
<td><code>scrollY</code></td>
<td><code>window</code> 对象</td>
<td>页面整体滚动条位置（别名 <code>pageYOffset</code>）</td>
<td>❌ 只读</td>
</tr>
</tbody></table>
<ul>
<li>offset<br>  只有元素节点（HTMLElement）才有 offset 系列属性。返回的数值都不带单位，包含padding+border+width，可视宽高，如果盒子隐藏则获取结果为0<ul>
<li>应用：获得元素和其父元素的距离、获得元素自身的大小（宽度高度）</li>
<li>offset 与 与  style . ( left  &#x2F;  top  &#x2F;  width  &#x2F;  height ) 的区别:</li>
</ul>
</li>
</ul>
<ol>
<li>offset系列的是只读属性,而通过style的方式可以读写</li>
<li>style.width 获得不包含padding和border 的值</li>
<li>offset系列返回的数值类型(结果四舍五入),style返回的是带单位的字符串 </li>
<li>style 可以返回没有定位的元素的left值和top值,而 offsetLeft 和 offsetTop 不可以</li>
</ol>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>offsetTop</code></td>
<td>元素相对于其 offsetParent 的顶部偏移</td>
</tr>
<tr>
<td><code>offsetLeft</code></td>
<td>元素相对于其 offsetParent 的左边偏移</td>
</tr>
<tr>
<td><code>offsetParent</code></td>
<td>定位参考容器（离当前元素最近的定位祖先）</td>
</tr>
<tr>
<td><code>offsetWidth</code></td>
<td>元素可见宽度（含 padding + border）</td>
</tr>
<tr>
<td><code>offsetHeight</code></td>
<td>元素可见高度（含 padding + border）</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.target&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> rect = el.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rect.<span class="property">top</span> &gt;= <span class="number">0</span> &amp;&amp; rect.<span class="property">top</span> &lt;= <span class="variable language_">window</span>.<span class="property">innerHeight</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;元素出现在可视区域了&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【offset】【scroll】【client】-对比"><a href="#【offset】【scroll】【client】-对比" class="headerlink" title="【offset】【scroll】【client】 对比"></a>【offset】【scroll】【client】 对比</h3><table>
<thead>
<tr>
<th>属性类别</th>
<th>代表属性</th>
<th>作用&#x2F;含义</th>
<th>所属对象类型</th>
<th>是否只读</th>
<th>常见用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>offset</code></td>
<td><code>offsetTop</code> &#x2F; <code>offsetLeft</code></td>
<td>元素<strong>相对 offsetParent 的偏移</strong>距离（定位用）</td>
<td>DOM 元素</td>
<td>✅ 是</td>
<td>元素定位、吸顶导航等</td>
</tr>
<tr>
<td></td>
<td><code>offsetWidth</code> &#x2F; <code>offsetHeight</code></td>
<td>元素<strong>包括 padding 和 border</strong> 的宽高</td>
<td>DOM 元素</td>
<td>✅ 是</td>
<td>获取元素实际尺寸</td>
</tr>
<tr>
<td><code>scroll</code></td>
<td><code>scrollTop</code> &#x2F; <code>scrollLeft</code></td>
<td>元素<strong>内容被卷起的距离</strong>（滚动了多少）</td>
<td>DOM 元素</td>
<td>❌ 否</td>
<td>获取&#x2F;设置滚动位置</td>
</tr>
<tr>
<td></td>
<td><code>scrollWidth</code> &#x2F; <code>scrollHeight</code></td>
<td>元素<strong>整体内容的宽高</strong>（包括看不见的部分）</td>
<td>DOM 元素</td>
<td>✅ 是</td>
<td>滚动加载、滚动检测等</td>
</tr>
<tr>
<td><code>client</code></td>
<td><code>clientTop</code> &#x2F; <code>clientLeft</code></td>
<td>元素<strong>内容区到边框的距离</strong>（通常是 border 宽度）</td>
<td>DOM 元素</td>
<td>✅ 是</td>
<td>校准滚动位置、精确定位</td>
</tr>
<tr>
<td></td>
<td><code>clientWidth</code> &#x2F; <code>clientHeight</code></td>
<td>元素<strong>可见区域宽高（内容 + padding，不含 border 和滚动条）</strong></td>
<td>DOM 元素</td>
<td>✅ 是</td>
<td>获取可视尺寸、布局控制</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>属性名</th>
<th>包含 padding</th>
<th>包含 border</th>
<th>包含滚动条</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>clientWidth</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>❌ 否</td>
<td>可见内容区域宽度（不含滚动条）</td>
</tr>
<tr>
<td><code>offsetWidth</code></td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>元素整体宽度（含 border）</td>
</tr>
<tr>
<td><code>scrollWidth</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>❌ 否</td>
<td>内容总宽度（包括溢出部分）</td>
</tr>
<tr>
<td><code>clientHeight</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>❌ 否</td>
<td>可见高度</td>
</tr>
<tr>
<td><code>offsetHeight</code></td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>元素整体高度</td>
</tr>
<tr>
<td><code>scrollHeight</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>❌ 否</td>
<td>总内容高度</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">网页可见区域宽： <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>; </span><br><span class="line">网页可见区域高： <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span>; </span><br><span class="line"></span><br><span class="line">网页真实元素宽： <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">offsetWidth</span> (包括边线的宽); </span><br><span class="line">网页真实元素高： <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">offsetHeight</span> (包括边线的宽); </span><br><span class="line"></span><br><span class="line">网页正文全文宽： <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollWidth</span>; </span><br><span class="line">网页正文全文高： <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span>; </span><br><span class="line"></span><br><span class="line">网页被卷去的高： <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>; </span><br><span class="line">网页被卷去的左： <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollLeft</span>; </span><br><span class="line"></span><br><span class="line">浏览器窗口的顶部边缘与屏幕的顶部边缘之间的距离： <span class="variable language_">window</span>.<span class="property">screenTop</span>; </span><br><span class="line">浏览器窗口的左边缘与屏幕的左边缘之间的距离： <span class="variable language_">window</span>.<span class="property">screenLeft</span>; </span><br><span class="line"></span><br><span class="line">屏幕分辨率的高： <span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">height</span>; </span><br><span class="line">屏幕分辨率的宽： <span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">width</span>; </span><br><span class="line"></span><br><span class="line">屏幕可用工作区高度： <span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">availHeight</span>; </span><br><span class="line">屏幕可用工作区宽度： <span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">availWidth</span>;</span><br></pre></td></tr></table></figure>
<h2 id="BOM（Browser-Object-Model）"><a href="#BOM（Browser-Object-Model）" class="headerlink" title="BOM（Browser Object Model）"></a>BOM（Browser Object Model）</h2><ul>
<li>定义浏览器对象模型，浏览器接口集合，用于操作浏览器窗口和浏览器环境。</li>
<li>作用：负责处理浏览器窗口、历史、位置、弹窗等。</li>
<li>包括：</li>
</ul>
<table>
<thead>
<tr>
<th>对象</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>window</code></td>
<td>浏览器窗口&#x2F;全局对象，BOM 顶级对象</td>
</tr>
<tr>
<td><code>navigator</code></td>
<td>浏览器信息，如用户代理、平台</td>
</tr>
<tr>
<td><code>screen</code></td>
<td>屏幕信息，如分辨率、颜色深度</td>
</tr>
<tr>
<td><code>location</code></td>
<td>当前文档的 URL 地址，href&#x2F;hash&#x2F;url</td>
</tr>
<tr>
<td><code>history</code></td>
<td>浏览器历史记录,go, forward&#x2F;back</td>
</tr>
<tr>
<td><code>console</code></td>
<td>控制台接口</td>
</tr>
<tr>
<td><code>alert</code>、<code>confirm</code>、<code>prompt</code></td>
<td>弹窗相关</td>
</tr>
<tr>
<td><code>setTimeout</code>、<code>setInterval</code></td>
<td>定时器函数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>属性&#x2F;方法</th>
<th>说明：window可省</th>
</tr>
</thead>
<tbody><tr>
<td><code>window.document</code></td>
<td>当前网页的 DOM 对象</td>
</tr>
<tr>
<td><code>window.location</code></td>
<td>当前页面的 URL 对象</td>
</tr>
<tr>
<td><code>window.history</code></td>
<td>浏览器历史记录</td>
</tr>
<tr>
<td><code>window.navigator</code></td>
<td>浏览器和操作系统信息</td>
</tr>
<tr>
<td><code>window.alert()</code></td>
<td>弹出警告框</td>
</tr>
<tr>
<td><code>window.confirm()</code></td>
<td>弹出确认框</td>
</tr>
<tr>
<td><code>window.prompt()</code></td>
<td>弹出输入框</td>
</tr>
<tr>
<td><code>window.setTimeout()</code></td>
<td>延时执行函数</td>
</tr>
<tr>
<td><code>window.setInterval()</code></td>
<td>定时重复执行函数</td>
</tr>
<tr>
<td><code>window.open()</code></td>
<td>打开新窗口</td>
</tr>
<tr>
<td><code>window.close()</code></td>
<td>关闭窗口</td>
</tr>
</tbody></table>
<p>window对象有innerWidth和innerHeight属性，<br>可以获取浏览器窗口的内部宽度和高度。<br>内部宽高是指除去菜单栏、工具栏、边框等占位元素后，<br>用于显示网页的净宽高。<br>还有一个outerWidth和outerHeight属性，<br>可以获取浏览器窗口的整个宽高。<br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/f5fcf78611ea4204b2aa5db8d3118f44.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>如一个完整的url:<br><a target="_blank" rel="noopener" href="http://www.example.com:8080/path/index.html?a=1&b=2#TOP">http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</a><br>location.protocol; &#x2F;&#x2F; ‘http’<br>location.host; &#x2F;&#x2F; ‘<a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a>‘<br>location.port; &#x2F;&#x2F; ‘8080’<br>location.pathname; &#x2F;&#x2F; ‘&#x2F;path&#x2F;index.html’<br>location.search; &#x2F;&#x2F; ‘?a&#x3D;1&amp;b&#x3D;2’<br>location.hash; &#x2F;&#x2F; ‘TOP’</p>
</blockquote>
<p>onload是页面内容全部加载完触发(包括图像、脚本文件、CSS 文件等)。唯一，后覆盖前。<br>DOMContentLoaded是仅DOM元素加载完触发，且从IE9开始支持。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> width = <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)<span class="comment">//没有唯一性限制</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br><span class="line"><span class="comment">//window也可以 不过最好是加在document上</span></span><br><span class="line"><span class="comment">//事件触发时仅DOM加载完成，不包括样式表、图片、flash等</span></span><br><span class="line"><span class="comment">//IE9以上才支持！！！</span></span><br><span class="line"><span class="comment">//如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, </span></span><br><span class="line"><span class="comment">//交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调整窗口大小事件 经常利用这个事件完成响应式布局。 </span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//禁止选中</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">getSelection</span> ? <span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">removeAllRanges</span>() : 				    <span class="variable language_">document</span>.<span class="property">selection</span>.<span class="title function_">empty</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">userAgent</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">platform</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">language</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">navigator.appName：浏览器名称；</span></span><br><span class="line"><span class="comment">navigator.appVersion：浏览器版本；</span></span><br><span class="line"><span class="comment">navigator.language：浏览器设置的语言；</span></span><br><span class="line"><span class="comment">navigator.platform：操作系统类型；</span></span><br><span class="line"><span class="comment">navigator.userAgent：浏览器设定的User-Agent字符串。</span></span><br><span class="line"><span class="comment">navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>((navigator.<span class="property">userAgent</span>.<span class="title function_">match</span>(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;&quot;</span>;     <span class="comment">//手机</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;&quot;</span>;     <span class="comment">//电脑</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测 userAgent（浏览器信息）</span></span><br><span class="line">!(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> userAgent = navigator.<span class="property">userAgent</span></span><br><span class="line"><span class="comment">// 验证是否为Android或iPhone</span></span><br><span class="line"><span class="keyword">const</span> android = userAgent.<span class="title function_">match</span>(<span class="regexp">/(Android);?[\s\/]+([\d.]+)?/</span>)</span><br><span class="line"><span class="keyword">const</span> iphone = userAgent.<span class="title function_">match</span>(<span class="regexp">/(iPhone\sOS)\s([\d_]+)/</span>)</span><br><span class="line"><span class="comment">// 如果是Android或iPhone，则跳转至移动站点</span></span><br><span class="line"><span class="keyword">if</span> (android || iphone) &#123;</span><br><span class="line">location.<span class="property">href</span> = <span class="string">&#x27;http://m.itcast.cn&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">href</span>);    <span class="comment">// 当前页面完整URL</span></span><br><span class="line">location.<span class="property">href</span> = <span class="string">&#x27;https://www.example.com&#x27;</span>;  <span class="comment">// 跳转到新页面</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">protocol</span>); <span class="comment">// 协议部分 http: 或 https:</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">host</span>);     <span class="comment">// 主机名和端口port</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">pathname</span>); <span class="comment">// 路径部分</span></span><br><span class="line">location.<span class="property">search</span> <span class="comment">//参数</span></span><br><span class="line">location.<span class="property">hash</span></span><br><span class="line">location.<span class="title function_">reload</span>();              <span class="comment">// 刷新当前页面</span></span><br><span class="line"><span class="comment">// 记录浏览历史，所以可以实现后退功能</span></span><br><span class="line">location.<span class="title function_">assign</span>(<span class="string">&#x27;http://www.itcast.cn&#x27;</span>);</span><br><span class="line"><span class="comment">// 不记录浏览历史，所以不可以实现后退功能</span></span><br><span class="line">location.<span class="title function_">replace</span>(<span class="string">&#x27;http://www.itcast.cn&#x27;</span>);</span><br><span class="line">            </span><br><span class="line">history.<span class="title function_">back</span>();   <span class="comment">// 后退</span></span><br><span class="line">history.<span class="title function_">forward</span>(); <span class="comment">// 前进</span></span><br><span class="line">history.<span class="title function_">go</span>(-<span class="number">1</span>);  <span class="comment">// 后退一页，go(1) 前进一页</span></span><br><span class="line"></span><br><span class="line">history.<span class="title function_">pushState</span>(stateObj, title, url); <span class="comment">// 改变历史记录（SPA 常用）</span></span><br><span class="line">history.<span class="title function_">replaceState</span>(stateObj, title, url); <span class="comment">// 替换当前历史记录</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(screen.<span class="property">width</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(screen.<span class="property">height</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(screen.<span class="property">colorDepth</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器-间歇函数 使用定时器函数重复执行代码</span></span><br><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setInterval</span>(回调函数, 间隔时间ms)</span><br><span class="line"><span class="built_in">clearInterval</span>(timerId)</span><br><span class="line"><span class="comment">//定时器需要等待，所以后面的代码先执行 </span></span><br><span class="line"><span class="comment">//每一次调用定时器都会产生一个新定时器</span></span><br><span class="line"><span class="built_in">setInterval</span>(repeat,<span class="number">1000</span>)<span class="comment">//第一次执行也是要间隔这ms数</span></span><br><span class="line"><span class="comment">//注意 即使clear了timeID依然在，所以要timeID=null才行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInterval</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> d=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">	clock.<span class="property">innerText</span>=d.<span class="title function_">toLocaleString</span>();</span><br><span class="line">	<span class="built_in">setTimeout</span>(myInterval,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>页面加载时执行JavaScript函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js文件中写</span></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"> <span class="keyword">function</span>  <span class="title function_">myfun</span>(<span class="params"></span>) 　　</span><br><span class="line">&#123; 　　 <span class="title function_">alert</span>( <span class="string">&quot;this window.onload&quot;</span> ); 　　</span><br><span class="line">&#125; 　　</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = myfun;  <span class="comment">/*用window.onload调用myfun()*/</span> 　　</span><br><span class="line"><span class="comment">//不要括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>= <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">func1</span>();</span><br><span class="line"><span class="title function_">func2</span>();</span><br><span class="line"><span class="title function_">func3</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件专题"><a href="#事件专题" class="headerlink" title="事件专题"></a>事件专题</h2><ul>
<li>事件循环<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41775119/article/details/147123962?fromshare=blogdetail&sharetype=blogdetail&sharerId=147123962&sharerefer=PC&sharesource=qq_41775119&sharefrom=from_link">点击跳转</a></li>
<li>事件流：指在网页或应用程序中，事件发生时所遵循的特定顺序和路径。<br>捕获阶段-&gt;目标阶段-&gt;冒泡阶段<br>事件捕获&#x2F;冒泡 (Event capture&#x2F;bubbling) 从外到内 从内到外 默认冒泡<blockquote>
<p>默认冒泡。在JavaScript中，可以使用 addEventListener 方法来指定在事件流的不同阶段对事件进行监听和处理。例如，通过设置 addEventListener 的第三个参数为 true ，可以在事件捕获阶段进行监听;设置为 false (默认值)则在事件冒泡阶段进行监听。</p>
</blockquote>
</li>
<li>事件代理 Event Delegation<br>将事件处理程序添加到父元素上，来管理子元素的事件处理。具体来说，事件代理是指将事件绑定到父元素上，当子元素触发事件时，该事件会冒泡到父元素，由父元素来处理该事件。这样做的好处是可以减少事件处理程序的数量，减轻页面的负担，提高代码的性能和可维护性。<br>应用场景：（性能优化）减少内存消耗、事件动态添加</li>
<li>mouseover v.s. mouseenter &#x2F; mouseout v.s. mouseleave：是否冒泡、仅在元素触发&#x2F;元素及子元素都触发</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>mouseover</th>
<th>mouseenter</th>
</tr>
</thead>
<tbody><tr>
<td>是否冒泡</td>
<td>会冒泡</td>
<td>❌ 不冒泡</td>
</tr>
<tr>
<td>子元素触发</td>
<td>进入子元素也会触发</td>
<td>❌ 进入子元素不会再触发｜</td>
</tr>
<tr>
<td>｜使用场景</td>
<td>一般用于处理整块区域的悬停效果</td>
<td>更适合精确处理当前元素悬停｜</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>属性</th>
<th>mouseout</th>
<th>mouseleave</th>
</tr>
</thead>
<tbody><tr>
<td>是否冒泡</td>
<td>会冒泡</td>
<td>❌ 不冒泡</td>
</tr>
<tr>
<td>子元素触发</td>
<td>移动到子元素也会触发</td>
<td>❌ 只在真正离开元素才触发</td>
</tr>
</tbody></table>
<ul>
<li>常用事件</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>常见事件示例</th>
</tr>
</thead>
<tbody><tr>
<td>用户交互事件</td>
<td>用户操作页面引发</td>
<td><code>click</code>, <code>dblclick</code>, <code>mousedown</code>, <code>mouseup</code>, <code>mousemove</code>, <code>mouseover</code>, <code>mouseout</code>, <code>mouseenter</code>, <code>mouseleave</code>, <code>keydown</code>, <code>keyup</code>, <code>keypress</code>, <code>input</code>, <code>change</code>, <code>focus</code>, <code>blur</code></td>
</tr>
<tr>
<td>表单事件</td>
<td>表单元素交互事件</td>
<td><code>submit</code>, <code>reset</code>, <code>input</code>, <code>change</code>, <code>focus</code>, <code>blur</code></td>
</tr>
<tr>
<td>触摸事件</td>
<td>移动设备上的触摸操作</td>
<td><code>touchstart</code>, <code>touchmove</code>, <code>touchend</code>, <code>touchcancel</code></td>
</tr>
<tr>
<td>剪贴板事件</td>
<td>剪切、复制、粘贴操作</td>
<td><code>copy</code>, <code>cut</code>, <code>paste</code></td>
</tr>
<tr>
<td>载入事件</td>
<td>页面或资源加载相关</td>
<td><code>load</code>, <code>DOMContentLoaded</code>, <code>beforeunload</code>, <code>unload</code></td>
</tr>
<tr>
<td>窗口事件</td>
<td>浏览器窗口尺寸、滚动相关</td>
<td><code>resize</code>, <code>scroll</code>, <code>error</code></td>
</tr>
<tr>
<td>拖放事件</td>
<td>拖拽操作相关</td>
<td><code>drag</code>, <code>dragstart</code>, <code>dragenter</code>, <code>dragover</code>, <code>dragleave</code>, <code>drop</code>, <code>dragend</code></td>
</tr>
<tr>
<td>媒体事件</td>
<td>音视频播放、暂停等</td>
<td><code>play</code>, <code>pause</code>, <code>ended</code>, <code>timeupdate</code>, <code>volumechange</code></td>
</tr>
<tr>
<td>其他事件</td>
<td>其他各种特殊事件</td>
<td><code>contextmenu</code>, <code>wheel</code>, <code>select</code></td>
</tr>
</tbody></table>
<p>keydown键盘按下<br>keyup键盘抬起<br>keypress键盘按下并弹起，onkeypress 和前面2个的区别是，它不识别功能键，比如左右箭头，shift，ctrl 等。<br>键盘事件执行顺序：keydown-&gt;keypress-&gt;keyup<br>onkeydown 和 onkeyup 不区分字母大小写，onkeypress 区分字母大小写。<br>e.key 替代keyCode返回改建的ascii码</p>
<table>
<thead>
<tr>
<th>按键</th>
<th><code>e.key</code> 返回值</th>
</tr>
</thead>
<tbody><tr>
<td>A-Z</td>
<td><code>&quot;a&quot;</code> - <code>&quot;z&quot;</code>（小写，和键盘大小写无关）</td>
</tr>
<tr>
<td>数字 0-9</td>
<td><code>&quot;0&quot;</code> - <code>&quot;9&quot;</code></td>
</tr>
<tr>
<td>Enter</td>
<td><code>&quot;Enter&quot;</code></td>
</tr>
<tr>
<td>空格</td>
<td><code>&quot; &quot;</code>（空字符串）</td>
</tr>
<tr>
<td>方向键</td>
<td><code>&quot;ArrowUp&quot;</code>, <code>&quot;ArrowDown&quot;</code>, <code>&quot;ArrowLeft&quot;</code>, <code>&quot;ArrowRight&quot;</code></td>
</tr>
<tr>
<td>Shift</td>
<td><code>&quot;Shift&quot;</code></td>
</tr>
<tr>
<td>Ctrl</td>
<td><code>&quot;Control&quot;</code></td>
</tr>
<tr>
<td>Alt</td>
<td><code>&quot;Alt&quot;</code></td>
</tr>
<tr>
<td>Backspace</td>
<td><code>&quot;Backspace&quot;</code></td>
</tr>
<tr>
<td>Escape</td>
<td><code>&quot;Escape&quot;</code></td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用场景：防止复制</span></span><br><span class="line"><span class="number">1.</span>禁止鼠标右键菜单</span><br><span class="line">contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;contextmenu&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">	e.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="number">2.</span>禁止鼠标选中（selectstart 开始选中）</span><br><span class="line"> <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;selectstart&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"> e.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addEventListener</span>(<span class="params">element, eventName, fn</span>) &#123;</span><br><span class="line"> <span class="comment">// 判断当前浏览器是否支持 addEventListener 方法</span></span><br><span class="line"> <span class="keyword">if</span> (element.<span class="property">addEventListener</span>) &#123;</span><br><span class="line"> element.<span class="title function_">addEventListener</span>(eventName, fn); <span class="comment">// 第三个参数 默认是false</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">attachEvent</span>) &#123;</span><br><span class="line"> element.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + eventName, fn);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 相当于 element.onclick = fn;</span></span><br><span class="line"> element[<span class="string">&#x27;on&#x27;</span> + eventName] = fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeEventListener</span>(<span class="params">element, eventName, fn</span>) &#123;</span><br><span class="line"> <span class="comment">// 判断当前浏览器是否支持 removeEventListener 方法</span></span><br><span class="line"> <span class="keyword">if</span> (element.<span class="property">removeEventListener</span>) &#123;</span><br><span class="line"> element.<span class="title function_">removeEventListener</span>(eventName, fn); <span class="comment">// 第三个参数 默认是false</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">detachEvent</span>) &#123;</span><br><span class="line"> element.<span class="title function_">detachEvent</span>(<span class="string">&#x27;on&#x27;</span> + eventName, fn);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> element[<span class="string">&#x27;on&#x27;</span> + eventName] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件对象（Event）<br>事件触发时会传入一个事件对象，包含事件信息（目标元素、事件类型、坐标等）<ul>
<li>e.target 和 this 的区别：<br>this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素）<br>e.target 是事件触发的元素。</li>
<li>常用属性：target, currentTarget, type, bubbles, cancelable</li>
<li>常用方法：preventDefault(), stopPropagation()</li>
<li>补充<br>1.type获取当前的事件类型<br>2.clientX&#x2F;clientY获取光标相对于浏览器可见窗口左上角的位置<br>3.offsetX&#x2F;offsetY获取光标相对于当前DOM元素左上角的位置<br>4.key用户按下的键盘键的值，现在不提倡使用keyCode已废弃（可读性差）<br>5.pageX&#x2F;pageY 鼠标相当于文档页面的X坐标&#x2F;Y坐标 IE9+支持<br>6.screenX&#x2F;screenY 鼠标相对于电脑屏幕的X坐标&#x2F;Y坐标<br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/a2c55f6226974fd7b4c05dc8910b706a.png" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<h1 id="ES6-新语法精选"><a href="#ES6-新语法精选" class="headerlink" title="ES6+ 新语法精选"></a>ES6+ 新语法精选</h1><table>
<thead>
<tr>
<th>ES6重点</th>
<th>内容</th>
<th>面试常考</th>
</tr>
</thead>
<tbody><tr>
<td>解构赋值</td>
<td>对象 &#x2F; 数组 &#x2F; 函数参数解构</td>
<td>⭐️⭐️⭐️⭐️</td>
</tr>
<tr>
<td>展开运算符</td>
<td><code>...</code> 拷贝、合并、rest 参数</td>
<td>⭐️⭐️⭐️⭐️</td>
</tr>
<tr>
<td>模板字符串</td>
<td>字符串插值</td>
<td>⭐️⭐️⭐️</td>
</tr>
<tr>
<td>模块化</td>
<td><code>import/export</code>、Tree-shaking</td>
<td>⭐️⭐️⭐️</td>
</tr>
<tr>
<td>可选链 &#x2F; 空值合并</td>
<td><code>?.</code> 和 <code>??</code></td>
<td>⭐️⭐️⭐️</td>
</tr>
</tbody></table>
<p>ES6一本通</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>&#x3D;&#x3D;待更新&#x3D;&#x3D;</p>
<h2 id="ESM-vs-CommonJS"><a href="#ESM-vs-CommonJS" class="headerlink" title="ESM vs CommonJS"></a>ESM vs CommonJS</h2><p>区别：</p>
<ul>
<li>CommonJS是对模块浅拷⻉，ES6 Module是对模块引⽤：ES6 Module只存只读，不能改变其值，指针指向不变，类似const；可对commonJS重新赋值（改变指针指向），但对ES6 Module赋值会编译报错。</li>
<li>import是read-only（只读状态）不能被重新赋值（不能改指针指向），但如果是对象类型可以修改对象内容（修改对象内部指针）；</li>
</ul>
<p>共同点：CommonJS和ES6 Module都可对对象赋值，即改变对象内部属性值。</p>
<table>
<thead>
<tr>
<th>比较维度</th>
<th>ES Module (ESM)新</th>
<th>CommonJS (CJS)</th>
</tr>
</thead>
<tbody><tr>
<td>语法</td>
<td><code>import/export</code></td>
<td><code>require/module.exports</code></td>
</tr>
<tr>
<td>加载机制</td>
<td>编译时静态分析 + 异步</td>
<td>动态运行时加载 + 同步</td>
</tr>
<tr>
<td>导入绑定</td>
<td>引用（Live）</td>
<td>拷贝</td>
</tr>
<tr>
<td>顶层 await</td>
<td>✅ 支持</td>
<td>❌ 不支持</td>
</tr>
<tr>
<td>浏览器支持</td>
<td>✅ 原生支持</td>
<td>❌ 不支持</td>
</tr>
<tr>
<td>Node 默认支持</td>
<td>扩展名<code>.mjs</code> 或 配置 <code>&quot;type&quot;: &quot;module&quot;</code></td>
<td>✅ 默认支持</td>
</tr>
<tr>
<td>适用场景</td>
<td>浏览器、现代 Node、构建工具</td>
<td>老项目、Node.js 脚本、兼容性强</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导出</span></span><br><span class="line"><span class="comment">// ESM</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CJS</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="comment">// ESM</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> defaultFn <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CJS</span></span><br><span class="line"><span class="keyword">const</span> &#123; a &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> defaultFn = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ul>
<li>作用：数组或对象；直接对多个变量同时赋值。还可以忽略某些元素。</li>
<li>规则：</li>
</ul>
<ol>
<li>如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性</li>
<li>可直接对嵌套的对象属性进行赋值，需要保证对应层次和key一致。</li>
<li>使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  [x, y, z] = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>];</span><br><span class="line"><span class="comment">/*如果数组本身还有嵌套，也可进行解构赋值，注意嵌套层次和位置要保持一致。*/</span></span><br><span class="line"><span class="keyword">let</span> [, , z] = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>]; <span class="comment">// 忽略前两个元素，只对z赋值第三个元素</span></span><br><span class="line">z; <span class="comment">// &#x27;ES6&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    <span class="attr">passport</span>: <span class="string">&#x27;G-12345678&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;No.4 middle school&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, age, passport&#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    <span class="attr">passport</span>: <span class="string">&#x27;G-12345678&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;No.4 middle school&#x27;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&#x27;Beijing&#x27;</span>,</span><br><span class="line">        <span class="attr">street</span>: <span class="string">&#x27;No.1 Road&#x27;</span>,</span><br><span class="line">        <span class="attr">zipcode</span>: <span class="string">&#x27;100001&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, <span class="attr">address</span>: &#123;city, zip&#125;&#125; = person;</span><br><span class="line">name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">city; <span class="comment">// &#x27;Beijing&#x27;</span></span><br><span class="line">zip; <span class="comment">// undefined, 因为属性名是zipcode而不是zip</span></span><br><span class="line"><span class="comment">// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:</span></span><br><span class="line">address; <span class="comment">// Uncaught ReferenceError: address is not defined</span></span><br></pre></td></tr></table></figure>
<p>如果要使用的变量名和属性名不一致，可以用下面的语法获取</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    <span class="attr">passport</span>: <span class="string">&#x27;G-12345678&#x27;</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;No.4 middle school&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把passport属性重命名为id:</span></span><br><span class="line"><span class="keyword">let</span> &#123;name, <span class="attr">passport</span>:id&#125; = person;</span><br><span class="line">name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">id; <span class="comment">// &#x27;G-12345678&#x27;</span></span><br><span class="line"><span class="comment">// 注意: passport不是变量，而是为了让变量id获得passport属性:</span></span><br><span class="line">passport; <span class="comment">// Uncaught ReferenceError: passport is not defined</span></span><br></pre></td></tr></table></figure>
<p>解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    <span class="attr">passport</span>: <span class="string">&#x27;G-12345678&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果person对象没有single属性，默认赋值为true:</span></span><br><span class="line"><span class="keyword">var</span> &#123;name, single=<span class="literal">true</span>&#125; = person;</span><br><span class="line">name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">single; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果变量已声明，再次赋值时，正确写法也会报语法错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明变量:</span></span><br><span class="line"><span class="keyword">var</span> x, y;</span><br><span class="line"><span class="comment">// 解构赋值:</span></span><br><span class="line">&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;;</span><br><span class="line"><span class="comment">// 语法错误: Uncaught SyntaxError: Unexpected token =</span></span><br></pre></td></tr></table></figure>
<p>这是因为JavaScript引擎把{开头语句当作块处理，所以&#x3D;不合法。解决方法是用小括号括起来：<br>({x, y} &#x3D; { name: ‘小明’, x: 100, y: 200});</p>
<h2 id="iterable-v-s-iterator"><a href="#iterable-v-s-iterator" class="headerlink" title="iterable v.s. iterator"></a>iterable v.s. iterator</h2><ul>
<li>定义<ul>
<li>Iterable 是可被遍历的对象，只要一个对象拥有 Symbol.iterator 方法，它就是 Iterable。<code>console.log(typeof [1,2,3][Symbol.iterator]); // function</code></li>
<li>迭代器 Iterator 是遍历时生成的“指针对象”，用来逐步访问每个元素，有 next() 方法，每次调用返回一个对象</li>
<li>两者关系<br>  Iterable 产生 Iterator<br>  可迭代对象调用其 Symbol.iterator() 方法后，返回一个 Iterator 对象。<code>const iter = arr[Symbol.iterator]();</code></li>
</ul>
</li>
<li>注意：普通Object、weapMap不是可迭代对象iterable</li>
<li>作用：懒加载遍历器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for ... of循环 只循环集合本身的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Map：一组键值对，极快的查找速度</span></span><br><span class="line"><span class="comment">//一个key只能对应一个value，所以多次对一个key放入value，后面的值会把前面的值冲掉</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;Michael&#x27;</span>, <span class="number">95</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>], [<span class="string">&#x27;Tracy&#x27;</span>, <span class="number">85</span>]]);</span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;Michael&#x27;</span>); <span class="comment">// 95</span></span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">//Map不能用索引取值，因为是按插入顺序保存键值对</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 是否存在key &#x27;Adam&#x27;: true</span></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 删除key &#x27;Adam&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set集合</span></span><br><span class="line"><span class="comment">//Set也是一组key的集合，但不存储value。</span></span><br><span class="line"><span class="comment">//由于key不能重复，所以在Set中，没有重复的key，重复元素在Set中自动被过滤</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br><span class="line">s.<span class="title function_">add</span>(key);</span><br><span class="line">s.<span class="title function_">delete</span>(key);</span><br><span class="line">s.<span class="title function_">has</span>(num) <span class="comment">//判断是否存在num</span></span><br></pre></td></tr></table></figure>
<h2 id="生成器generator"><a href="#生成器generator" class="headerlink" title="生成器generator"></a>生成器generator</h2><ul>
<li>作用：Generator（生成器）是 JavaScript 中的一种特殊函数，用于控制函数的执行流程、实现“暂停与恢复”，它是构建异步流程控制、惰性迭代器、高级控制流的利器。替代复杂的 iterator 写法。<br>generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处类似于AJAX。<br>看上去是同步的代码，实际执行是异步的。</li>
<li>定义：Generator 是可以“暂停执行”的函数，每次调用 next() 执行一步，遇到 yield 暂停，外部再调用 next() 继续。generator和函数不同的是，generator由function<em>定义（注意多出的</em>号），除了return语句，还可以用yield返回多次</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fib</span>(<span class="params">max</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; max) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        n ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fib</span>(<span class="number">5</span>); </span><br><span class="line"><span class="comment">//直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。</span></span><br><span class="line"><span class="comment">//调用generator对象有两个方法，一是不断地调用generator对象的next()方法：</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">fib</span>(<span class="number">5</span>);</span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">next()方法会执行generator的代码，</span></span><br><span class="line"><span class="comment">每次遇到yield x;就返回一个对象&#123;value: x, done: true/false&#125;，然后“暂停”。</span></span><br><span class="line"><span class="comment">返回的value就是yield的返回值，</span></span><br><span class="line"><span class="comment">done表示这个generator是否已经执行结束了。</span></span><br><span class="line"><span class="comment">如果done为true，则value就是return的返回值。</span></span><br><span class="line"><span class="comment">当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个方法是直接用for ... of循环迭代generator对象，这种方式不需要我们自己判断done</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> <span class="title function_">fib</span>(<span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 依次输出0, 1, 1, 2, 3, ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    r1 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&#x27;http://url-1&#x27;</span>, data1);</span><br><span class="line">    r2 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&#x27;http://url-2&#x27;</span>, data2);</span><br><span class="line">    r3 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&#x27;http://url-3&#x27;</span>, data3);</span><br><span class="line">    <span class="title function_">success</span>(r3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰器-decorator"><a href="#装饰器-decorator" class="headerlink" title="装饰器 decorator"></a>装饰器 decorator</h2><ul>
<li>定义：JavaScript 的 装饰器（decorators） 是一种用于修改类和类方法行为的语法。装饰器本质上是函数，用来增强、修改或替换类或类方法的功能。装饰器是 ES2022（即 ECMAScript 2022）的一部分，虽然目前很多浏览器还不完全支持，但你可以通过 Babel 等工具启用它。</li>
<li>应用：<br>日志记录：自动记录方法调用的日志。<br>权限控制：在类方法前加上装饰器，进行权限验证。<br>缓存：给方法加上装饰器进行缓存，避免重复计算。<br>观察者模式：通过装饰器观察对象状态的变化。</li>
<li>需要注意的事项：<br>装饰器需要在 class 或方法定义前使用 @ 符号进行标记。<br>装饰器语法并不是 JavaScript 标准的一部分，虽然已经被提案并在 ECMAScript 2022 中正式接受，但在实际使用时仍需依赖工具（如 Babel）进行转译。<br>装饰器的行为修改是浅拷贝的，无法对类本身的实例进行深度操作。</li>
</ul>
<ol>
<li>类装饰器<br>类装饰器用于修改类的构造函数或类本身。它是一个函数，接收类的构造函数作为参数，并返回一个修改后的构造函数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myDecorator</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target); <span class="comment">// 输出类的构造函数</span></span><br><span class="line">  target.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">decorated</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@myDecorator</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">decorated</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>方法装饰器<br>方法装饰器用于修改类方法的行为。它接收三个参数：<br>类的原型（如果是实例方法）或构造函数（如果是静态方法）<br>方法名<br>方法描述符（descriptor）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">log 装饰器拦截了 add 方法的调用，打印了传入的参数和返回的结果。</span></span><br><span class="line"><span class="comment">方法装饰器通过 descriptor 对象修改方法的行为。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">target, key, descriptor</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> originalMethod = descriptor.<span class="property">value</span>;</span><br><span class="line">  descriptor.<span class="property">value</span> = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Calling <span class="subst">$&#123;key&#125;</span> with arguments: <span class="subst">$&#123;args&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">const</span> result = originalMethod.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> returned: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  @log</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">instance.<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// Calling add with arguments: [1, 2]</span></span><br><span class="line"><span class="comment">// add returned: 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">parseInt</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>属性装饰器<br>属性装饰器用于修改类实例的属性。它只能作用于类的属性声明，但不能直接修改属性的值。</li>
</ol>
<ul>
<li>属性描述符（Property Descriptor）<br>属性描述符 是 JavaScript 中 用来描述对象属性特性 的对象。它定义了属性的 可写性、可枚举性 和 可配置性 等特性。<br>属性描述符分为两种类型：</li>
</ul>
<ol>
<li>数据属性（Data Descriptor）</li>
<li>访问器属性（Accessor Descriptor）<br>(1) 数据属性<br>数据属性是存储实际值的属性，包含以下四个特性：</li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>value</code></td>
<td>该属性的值</td>
</tr>
<tr>
<td><code>writable</code></td>
<td>是否可以修改该属性的值（<code>true</code> &#x2F; <code>false</code>）</td>
</tr>
<tr>
<td><code>enumerable</code></td>
<td>是否可以在 <code>for...in</code> 或 <code>Object.keys()</code> 里遍历（<code>true</code> &#x2F; <code>false</code>）</td>
</tr>
<tr>
<td><code>configurable</code></td>
<td>是否可以删除或修改该属性的特性（<code>true</code> &#x2F; <code>false</code>）</td>
</tr>
</tbody></table>
<p>(2) 访问器属性<br>访问器属性不存储值，而是通过 getter 和 setter 进行访问和修改。它包含以下四个特性：<br>get	获取属性时调用的函数<br>set	设置属性时调用的函数<br>enumerable	是否可以在 for…in 或 Object.keys() 里遍历<br>configurable	是否可以删除或修改该属性的特性</p>
<blockquote>
<p>getter（获取器）和 setter（设置器）是对象的访问器属性，用于控制属性的获取和赋值行为，而不是直接存储值。<br>getter（获取器）用于 定义当访问属性时执行的函数。<br>通过 get 关键字定义。<br>getter 没有参数，必须返回一个值。</p>
</blockquote>
<blockquote>
<p>setter（设置器）用于 定义当设置属性时执行的函数。<br>通过 set 关键字定义。<br>setter 接受一个参数，表示新赋的值。</p>
</blockquote>
<blockquote>
<p>为什么要用getter ,setter？生成一个独立的属性<br>如果你只定义 getter 而不定义 setter，属性就是只读的</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">value</span>) &#123;  <span class="comment">// 定义 setter</span></span><br><span class="line">    <span class="keyword">const</span> parts = value.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstName</span> = parts[<span class="number">0</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastName</span> = parts[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="property">fullName</span> = <span class="string">&quot;Bob Johnson&quot;</span>; <span class="comment">// 触发 setter</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">firstName</span>); <span class="comment">// &quot;Bob&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">lastName</span>);  <span class="comment">// &quot;Johnson&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">readonly 装饰器使得 name 属性变为只读。</span></span><br><span class="line"><span class="comment">在尝试修改 name 时会抛出错误。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">readonly 装饰器通过修改对象属性的 属性描述符（descriptor）来实现只读功能</span></span><br><span class="line"><span class="comment">属性描述符（Descriptor）</span></span><br><span class="line"><span class="comment">在 JavaScript 中，每个对象的属性都可以有一个 属性描述符（descriptor），这个描述符包含了该属性的一些特性，例如：</span></span><br><span class="line"><span class="comment">writable：决定属性是否可以被修改。</span></span><br><span class="line"><span class="comment">configurable：决定属性是否可以被删除或修改。</span></span><br><span class="line"><span class="comment">enumerable：决定属性是否可以出现在 for...in 循环和 Object.keys() 中。</span></span><br><span class="line"><span class="comment">get 和 set：用于定义 getter 和 setter 方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Object.defineProperty() 和 属性描述符</span></span><br><span class="line"><span class="comment">Object.defineProperty() 是 JavaScript 提供的一个方法，定义或修改对象的属性，同时也能设置这些属性的描述符。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(对象，修改或新增的属性名，&#123;</span><br><span class="line">		<span class="attr">value</span>:修改或新增的属性的值,</span><br><span class="line">		<span class="attr">writable</span>:<span class="literal">true</span>/<span class="literal">false</span>,<span class="comment">//如果值为false 不允许修改这个属性值</span></span><br><span class="line">		<span class="attr">enumerable</span>: <span class="literal">false</span>,<span class="comment">//enumerable 如果值为false 则不允许遍历</span></span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">false</span>  <span class="comment">//configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性</span></span><br><span class="line">&#125;)	</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,  <span class="comment">// 设置为只读</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readonly</span>(<span class="params">target, key, descriptor</span>) &#123;</span><br><span class="line">  <span class="comment">// 修改属性描述符</span></span><br><span class="line">  descriptor.<span class="property">writable</span> = <span class="literal">false</span>;  <span class="comment">// 设置属性为只读</span></span><br><span class="line">  <span class="keyword">return</span> descriptor;  <span class="comment">// 返回修改后的描述符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">target：指的是目标对象（类的原型，或者实例）。</span></span><br><span class="line"><span class="comment">key：指的是属性名或方法名。</span></span><br><span class="line"><span class="comment">descriptor：指的是属性或方法的描述符，其中包含了属性的各种设置（例如 writable、configurable、enumerable 等）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readonly</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> descriptor = &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">name</span>); <span class="comment">// &quot;John Doe&quot;</span></span><br><span class="line">instance.<span class="property">name</span> = <span class="string">&quot;Jane Doe&quot;</span>; <span class="comment">// TypeError: Cannot assign to read only property &#x27;name&#x27;</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>访问器装饰器（getter&#x2F;setter）<br>访问器装饰器可以应用于类的 getter 或 setter 方法，允许你对这些访问器进行修饰。<br>类的 getter 和 setter 方法是 JavaScript 中的一种特殊方法，用于访问和设置对象的属性。它们提供了对对象属性的封装，允许你在获取或修改属性时执行额外的逻辑。通过 getter 和 setter，你可以控制如何读取和修改对象的属性。<blockquote>
<p>Getter（访问器）<br>getter 是一个方法，它允许你定义对象属性的读取行为。它会在访问该属性时自动调用。<br>Setter（设置器）<br>setter 是一个方法，它允许你定义对象属性的设置行为。它会在给该属性赋值时自动调用。<br>使用 getter 和 setter 的场景<br>数据验证：可以在设置属性值之前进行验证，确保其有效性。<br>懒加载：如果属性值比较复杂，可以在 getter 中做懒加载（延迟计算），避免每次访问都进行计算。<br>属性代理：你可以通过 getter 和 setter 来创建虚拟属性，这些属性并不直接存储在对象中，而是计算得出的。</p>
</blockquote>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">firstName, lastName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastName</span> = lastName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Getter：懒加载 fullName</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Calculating full name...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">fullName</span>); <span class="comment">// &quot;Calculating full name...&quot; 和 &quot;John Doe&quot; 会输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有时，我们希望类的某些属性不能直接访问，可以通过添加前缀 _ 来表示它们是私有的，但实际还是通过 getter 和 setter 来访问它们。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = value;  <span class="comment">// 私有属性，通常以 _ 开头</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Getter 方法</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Getting value&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setter 方法</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Setting value to &quot;</span> + newValue);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">target, key, descriptor</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> getter = descriptor.<span class="property">get</span>;</span><br><span class="line">  descriptor.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting <span class="subst">$&#123;key&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> getter.<span class="title function_">apply</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_age</span> = <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  @log</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_age</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">age</span>); <span class="comment">// &quot;Getting age&quot; 然后 &quot;30&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>静态方法装饰器<br>静态方法装饰器与实例方法装饰器类似，但它应用于静态方法。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">staticDecorator</span>(<span class="params">target, key, descriptor</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Static method <span class="subst">$&#123;key&#125;</span> is being decorated`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  @staticDecorator</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Static method&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">staticMethod</span>(); <span class="comment">// Static method staticMethod is being decorated</span></span><br></pre></td></tr></table></figure>

<h1 id="异常处理与工具函数"><a href="#异常处理与工具函数" class="headerlink" title="异常处理与工具函数"></a>异常处理与工具函数</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    tryCode - 尝试执行代码块</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    catchCode - 捕获错误的代码块</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    finallyCode - 无论 <span class="keyword">try</span> / <span class="keyword">catch</span> 结果如何都会执行的代码块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRectArea</span>(<span class="params">width, height</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isNaN</span>(width) || <span class="built_in">isNaN</span>(height)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Parameter is not a number!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">getRectArea</span>(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  <span class="comment">// expected output: &quot;Parameter is not a number!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>throw<br><code>throw</code> 抛出异常信息，后面跟的是错误提示信息<br> <code>Error</code> 对象配合 <code>throw</code> 使用，能够设置更详细的错误信息<br>当前函数执行停止（throw之后的语句将不会执行），并且控制将被传递到调用堆栈中的第一个catch块。如果调用者函数中没有catch块，程序将会终止。</li>
</ol>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">counter</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!x || !y) &#123;</span><br><span class="line">    <span class="comment">// throw &#x27;参数不能为空!&#x27;;</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数不能为空!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">counter</span>();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>try…catch<br><code>try...catch</code> 用于捕获错误信息<br> 将预估可能发生错误的代码写在 <code>try</code> 代码段中<br> 如果 <code>try</code> 代码段中出现错误后，会执行 <code>catch</code> 代码段，并截获到错误信息</li>
</ol>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 查找 DOM 节点</span></span><br><span class="line">    <span class="keyword">var</span> p = docunent.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    <span class="comment">// try 代码段中执行有错误时，会执行 catch 代码段</span></span><br><span class="line">    <span class="comment">// 查看错误信息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">message</span>);</span><br><span class="line">    <span class="comment">// 终止代码继续执行</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 改变文本样式</span></span><br><span class="line">  p.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义错误<br>&#x3D;&#x3D;待更新&#x3D;&#x3D;</li>
</ul>
<h2 id="常见工具-函数封装"><a href="#常见工具-函数封装" class="headerlink" title="常见工具&#x2F;函数封装"></a>常见工具&#x2F;函数封装</h2><p>（节流、防抖、深拷贝、类型判断）</p>
<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><ul>
<li>定义<br>浅拷贝（Shallow Copy）：只复制第一层，嵌套对象还是引用原来的。<br>深拷贝（Deep Copy）：递归复制所有层级，嵌套对象是全新的副本，互不影响。</li>
<li>实现<ul>
<li>深拷贝</li>
</ul>
</li>
</ul>
<ol>
<li>JSON.stringify()<br>JSON.parse(JSON.stringify(obj))是目前比较常用的深拷贝方法之一，它的原理就是利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象。<br>但是还存在问题，无法拷贝函数，undefined，symbol、不可枚举的属性、原型链，当使用过JSON.stringify()进行处理之后，都会消失；对象中含有 NaN、正负Infinity，得到 JSON 序列化结果 null；</li>
<li>函数库lodash的_.cloneDeep方法</li>
<li>手写<br>但同样是上面说过的问题没解决。<br>对象的属性里面成环，即循环引用没有解决。<br>递归的深度的深度太深就会引发栈内存的溢出<ul>
<li>浅拷贝<br>直接赋值、Object.assign()、扩展运算符、手写</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">      <span class="comment">//区别在这 不继续递归了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝的实现;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] =</span><br><span class="line">        <span class="keyword">typeof</span> object[key] === <span class="string">&quot;object&quot;</span> ? <span class="title function_">deepCopy</span>(object[key]) : object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="节流阀"><a href="#节流阀" class="headerlink" title="节流阀"></a>节流阀</h2><p>防止轮播图按钮连续点击造成播放过快。<br>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。<br>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。<br>开始设置一个变量 var flag &#x3D; true;<br>If(flag) {flag &#x3D; false; do something} 关闭水龙头<br>利用回调函数 动画执行完毕， flag &#x3D; true 打开水龙头</p>
<ul>
<li>计算代码性能</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> startTime = performance.<span class="title function_">now</span>(); </span><br><span class="line"><span class="comment">// 某些程序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> endTime = performance.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">const</span> totaltime = endTime - startTime;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(totaltime); <span class="comment">// 30.299999952316284</span></span><br></pre></td></tr></table></figure>

<h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><ul>
<li>触屏事件概述<br>在移动端，touch事件比鼠标事件执行效率高<br>移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android 和 IOS 都有。<br>touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。<br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/16e0352307a44fa78a12420d43782853.png" alt="在这里插入图片描述"><br>如果移动距离小于 某个像素 就回弹原来位置<br>如果移动距离大于某个像素就上一张下一张滑动。<br>滑动也分为左滑动和右滑动 判断的标准是 移动距离正负 如果是负值就是左滑 反之右滑</li>
<li>触摸事件对象（TouchEvent）<br>TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多<br>个触点，使开发者可以检测触点的移动，触点的增加和减少，等等<br>touchstart、touchmove、touchend 三个事件都会各自有事件对象。<br>触摸事件对象重点我们看三个常见对象列表：<br>targetTouches属性和touches在手指按下和移动中都可以获取手指列表<br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/b4df40a74e1a46829f4f548d4a214a32.png" alt="在这里插入图片描述"><br>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTouches</li>
<li>移动端拖动元素</li>
</ul>
<ol>
<li>touchstart、touchmove、touchend 可以实现拖动元素</li>
<li>但是拖动元素需要当前手指的坐标值 我们可以使用 targetTouches[0] 里面的pageX 和 pageY </li>
<li>移动端拖动的原理： 手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离</li>
<li>手指移动的距离： 手指滑动中的位置 减去 手指刚开始触摸的位置<br>拖动元素三步曲：<br>（1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置<br>（2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子<br>（3） 离开手指 touchend:<br>注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();</li>
</ol>
<ul>
<li>移动端常用开发插件<br>比如移动端常见插件：iScroll、Swiper、SuperSlider 。<br><a target="_blank" rel="noopener" href="https://www.swiper.com.cn/">https://www.swiper.com.cn/</a><br>superslide： <a target="_blank" rel="noopener" href="http://www.superslide2.com/">http://www.superslide2.com/</a><br>iscroll： <a target="_blank" rel="noopener" href="https://github.com/cubiq/iscrol">https://github.com/cubiq/iscrol</a><br>移动端视频插件 zy.media.js<br>H5 给我们提供了 video 标签，但是浏览器的支持情况不同。在移动端我们可以使用插件方式来制作。</li>
<li>click 延时解决方案<br>移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。<br>fastclick 插件解决 300ms 延迟。 使用延时<br>GitHub官网地址： <a target="_blank" rel="noopener" href="https://github.com/ftlabs/fastclick">https://github.com/ftlabs/fastclick</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决方案</span></span><br><span class="line"><span class="comment">//1 禁用缩放，浏览器禁用默认的双击缩放行为并且去掉 300ms 的点击延迟。</span></span><br><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;user-scalable=no&quot;</span>&gt;</span><br><span class="line"><span class="comment">//2 使用插件。 fastclick 插件解决 300ms 延迟。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;addEventListener&#x27;</span> <span class="keyword">in</span> <span class="variable language_">document</span>) &#123;</span><br><span class="line"> <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title class_">FastClick</span>.<span class="title function_">attach</span>(<span class="variable language_">document</span>.<span class="property">body</span>);<span class="comment">/*等页面文档加载完成 不需要等所有的资源*/</span></span><br><span class="line"> &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 利用touch事件自己封装这个事件解决 300ms 延迟。</span></span><br><span class="line"><span class="comment">//如果离开屏幕到触摸屏幕时间差值小于150ms，并且没有滑动过屏幕，那么我们就定义为点击</span></span><br><span class="line"><span class="comment">//封装tap，解决click 300ms 延时</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tap</span> (<span class="params">obj, callback</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> isMove = <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">var</span> startTime = <span class="number">0</span>; <span class="comment">// 记录触摸时候的时间变量</span></span><br><span class="line"> obj.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line"> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 记录触摸时间</span></span><br><span class="line"> &#125;);</span><br><span class="line"> obj.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line"> isMove = <span class="literal">true</span>; <span class="comment">// 看看是否有滑动，有滑动算拖拽，不算点击</span></span><br><span class="line"> &#125;);</span><br><span class="line"> obj.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (!isMove &amp;&amp; (<span class="title class_">Date</span>.<span class="title function_">now</span>() - startTime) &lt; <span class="number">150</span>) &#123; <span class="comment">// 如果手指触摸和离开时间小于150ms 算点击</span></span><br><span class="line"> callback &amp;&amp; <span class="title function_">callback</span>(); <span class="comment">// 执行回调函数</span></span><br><span class="line"> &#125;</span><br><span class="line"> isMove = <span class="literal">false</span>; <span class="comment">// 取反 重置</span></span><br><span class="line"> startTime = <span class="number">0</span>;</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用 </span></span><br><span class="line"> <span class="title function_">tap</span>(div, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">// 执行代码 &#125;);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>淘宝 flexible.js 源码分析<br>立即执行函数 (function(){})()  或者 (function(){}())<br>主要作用： 创建一个独立的作用域。 避免了命名冲突问题<br>下面三种情况都会刷新页面都会触发 load 事件。<br>1.a标签的超链接<br>2.F5或者刷新按钮（强制刷新）<br>3.前进后退按钮<br>但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。<br>所以此时后退按钮不能刷新页面。<br>此时可以使用 pageshow事件来触发。这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件&#96;注意这个事件给window添加。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pageshow&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">persisted</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;页面来自缓存&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;页面是重新加载的&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">flexible</span>(<span class="params"><span class="variable language_">window</span>, <span class="variable language_">document</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取的html 的根元素</span></span><br><span class="line">    <span class="keyword">var</span> docEl = <span class="variable language_">document</span>.<span class="property">documentElement</span></span><br><span class="line">        <span class="comment">// dpr 物理像素比</span></span><br><span class="line">    <span class="keyword">var</span> dpr = <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span> || <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// adjust body font size  设置我们body 的字体大小</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setBodyFontSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 如果页面中有body 这个元素 就设置body的字体大小</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = (<span class="number">12</span> * dpr) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果页面中没有body 这个元素，则等着 我们页面主要的DOM元素加载完毕再去设置body</span></span><br><span class="line">            <span class="comment">// 的字体大小</span></span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, setBodyFontSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setBodyFontSize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set 1rem = viewWidth / 10    设置我们html 元素的文字大小</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setRemUnit</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> rem = docEl.<span class="property">clientWidth</span> / <span class="number">10</span></span><br><span class="line">        docEl.<span class="property">style</span>.<span class="property">fontSize</span> = rem + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">setRemUnit</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset rem unit on page resize  当我们页面尺寸大小发生变化的时候，要重新设置下rem 的大小</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, setRemUnit)</span><br><span class="line">        <span class="comment">// pageshow 是我们重新加载页面触发的事件</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pageshow&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="comment">// e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小</span></span><br><span class="line">        <span class="keyword">if</span> (e.<span class="property">persisted</span>) &#123;</span><br><span class="line">            <span class="title function_">setRemUnit</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// detect 0.5px supports  有些移动端的浏览器不支持0.5像素的写法</span></span><br><span class="line">    <span class="keyword">if</span> (dpr &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> fakeBody = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line">        <span class="keyword">var</span> testElement = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">        testElement.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;.5px solid transparent&#x27;</span></span><br><span class="line">        fakeBody.<span class="title function_">appendChild</span>(testElement)</span><br><span class="line">        docEl.<span class="title function_">appendChild</span>(fakeBody)</span><br><span class="line">        <span class="keyword">if</span> (testElement.<span class="property">offsetHeight</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            docEl.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;hairlines&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        docEl.<span class="title function_">removeChild</span>(fakeBody)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="variable language_">window</span>, <span class="variable language_">document</span>))</span><br></pre></td></tr></table></figure>
<h1 id="includes-v-s-in"><a href="#includes-v-s-in" class="headerlink" title="includes v.s. in"></a>includes v.s. in</h1><ul>
<li>includes() 可以在多种数据类型上使用，主要用于检查一个集合（或字符串）中是否包含某个特定的元素。<br>它在以下几种内置类型上都有定义：<br>Array.prototype.includes() (数组类型)<br>String.prototype.includes() (字符串类型)<br>TypedArray.prototype.includes() (类型化数组，例如 Int8Array, Uint8Array 等)</li>
<li>JavaScript 是有 in 运算符的用法的<br>  in 运算符在 JavaScript 中是用来判断对象是否包含某个属性（无论是对象自身的属性还是继承来的属性）。<ul>
<li>与 hasOwnProperty() 的区别<br>  in 运算符会检查对象自身及其原型链上是否存在某个属性。<br>  而 Object.prototype.hasOwnProperty() 方法只检查对象自身是否拥有某个属性，不包括原型链上的属性。</li>
</ul>
</li>
</ul>
<h1 id="正则表达式-RegExp"><a href="#正则表达式-RegExp" class="headerlink" title="正则表达式(RegExp)"></a>正则表达式(RegExp)</h1><blockquote>
<p>注意：如果是代码是被作为字符串插入到另一个代码的，要做好充分转义，放入new RegExp还要再加一层转义。</p>
</blockquote>
<p>作用：表单验证、过滤敏感词、提取想要部分字符串</p>
<ul>
<li>^作为取反符和边界符的区别<br>边界符：写在方括号外面<br>取反符：写在方括号里面</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rname=<span class="regexp">/expression/</span></span><br><span class="line"><span class="comment">// /表达式/就表示是正则表达式</span></span><br><span class="line">regObj.<span class="title function_">test</span>(被检测字符串)<span class="comment">//检测是否与正则表达式匹配 返回true/false</span></span><br><span class="line">regObj.<span class="title function_">exec</span>(被检测字符串)<span class="comment">//在一个指定字符串中执行一个搜索匹配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isAlphaNumeric</span>(<span class="params">char</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^[a-zA-Z0-9]$/</span>.<span class="title function_">test</span>(char);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 举例子：输出的结果[&quot;o&quot;, index: 4, input: &quot;hello&quot;, groups: undefined]</span></span><br><span class="line"><span class="comment">//如果匹配成功，exec() 方法返回一个数组，否则返回null</span></span><br><span class="line"><span class="comment">/*全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。</span></span><br><span class="line"><span class="comment">当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，</span></span><br><span class="line"><span class="comment">表示上次匹配到的最后索引：*/</span></span><br><span class="line">string.<span class="title function_">replace</span>(<span class="regexp">/exp/</span>,<span class="string">&#x27;new_word&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> match = string.<span class="title function_">match</span>(regex)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果匹配成功，返回一个数组</span></span><br><span class="line"><span class="comment">如果没有匹配，返回 null</span></span><br><span class="line"><span class="comment">match[0]	整个正则表达式匹配到的字符串（整行）</span></span><br><span class="line"><span class="comment">match[1]	第一个 () 捕获组内容（标题前面的井号）</span></span><br><span class="line"><span class="comment">match[2]	第二个 () 捕获组内容（标题文本）</span></span><br><span class="line"><span class="comment">...	如果正则有更多 () 捕获组，就会继续往后放入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//元字符 指表示特殊含义的符号，能够匹配一类 如[a-z]</span></span><br><span class="line"><span class="comment">//边界符：位置开头结尾</span></span><br><span class="line">^开头</span><br><span class="line">$结尾</span><br><span class="line"></span><br><span class="line"><span class="comment">//量词：重复次数</span></span><br><span class="line">* <span class="comment">//重复任意次 包括0次</span></span><br><span class="line">+ <span class="comment">//重复一次或更多次</span></span><br><span class="line">? <span class="comment">//重复0次或一次</span></span><br><span class="line">&#123;n&#125; </span><br><span class="line">&#123;n,&#125;</span><br><span class="line">&#123;n,m&#125; <span class="comment">//逗号两侧不要出现空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符类</span></span><br><span class="line">[匹配字符集合] 如[abc]</span><br><span class="line">[a-z]</span><br><span class="line">[a-zA-Z]</span><br><span class="line">[<span class="number">0</span>-<span class="number">9</span>]</span><br><span class="line">[a-zA-<span class="variable constant_">Z0</span>-<span class="number">9</span>-_]</span><br><span class="line">[^abc] <span class="comment">//取反符号 不能是abc</span></span><br><span class="line">. <span class="comment">//匹配除换行符之外任何单个字符</span></span><br><span class="line">\d [<span class="number">0</span>-<span class="number">9</span>]</span><br><span class="line">\D [^<span class="number">0</span>-<span class="number">9</span>]</span><br><span class="line">\w [a-zA-<span class="variable constant_">Z0</span>-<span class="number">9</span>-_]</span><br><span class="line">\W 除\w之外</span><br><span class="line">\s 匹配空格包括换行符、制表符、空格符等 [\t\r\n\v\f]</span><br><span class="line">\S 匹配除\s之外</span><br><span class="line">|  用来表示“匹配其中任意一个”的意思。</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line">^\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;\ <span class="comment">//日期</span></span><br><span class="line">/^[a-zA-<span class="variable constant_">Z0</span>-<span class="number">9</span>-_]&#123;<span class="number">6</span>,<span class="number">10</span>&#125;$/ <span class="comment">//用户名</span></span><br><span class="line"><span class="regexp">/^1(3\d|4[5-9]|5[0-35-9]|6[567]|7[0-8]|8\d|9[0-35-9])\d&#123;8&#125;$/</span> <span class="comment">//手机号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修饰符</span></span><br><span class="line"><span class="regexp">/表达式/</span>修饰符</span><br><span class="line">i <span class="comment">//ignore 不区分大小写</span></span><br><span class="line">g <span class="comment">//global 匹配所有满足正则表达式的结果</span></span><br><span class="line">m<span class="comment">//表示执行多行匹配</span></span><br><span class="line">gi <span class="comment">//组合使用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>‘00\d’可以匹配’007’<br>\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格</p>
<p><strong>由于’-‘是特殊字符，在正则表达式中，要用’&#39;转义</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线；</span><br><span class="line">[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串</span><br><span class="line">[a-zA-Z\_\$][0-9a-zA-Z\_\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串</span><br><span class="line">[a-zA-Z\_\$][0-9a-zA-Z\_\$]&#123;0, 19&#125;更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）</span><br></pre></td></tr></table></figure>
<p><strong>A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配’JavaScript’、’Javascript’、’javaScript’或者’javascript’</strong></p>
<ul>
<li>分组<br>用()表示的就是要提取的分组<br>如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。<br>exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串<br>exec()方法在匹配失败时返回null</li>
<li>贪婪匹配 or 非贪婪匹配<br>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。<br><code>.*</code> v.s.<code>.*?</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</span><br><span class="line">re.<span class="title function_">exec</span>(<span class="string">&#x27;102300&#x27;</span>); <span class="comment">// [&#x27;102300&#x27;, &#x27;102300&#x27;, &#x27;&#x27;]</span></span><br><span class="line">\d+采用贪婪匹配，直接把后面的<span class="number">0</span>全部匹配了，结果<span class="number">0</span>*只能匹配空字符串了</span><br><span class="line"></span><br><span class="line">必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<span class="number">0</span>匹配出来，加个?就可以让\d+采用非贪婪匹配</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</span><br><span class="line">re.<span class="title function_">exec</span>(<span class="string">&#x27;102300&#x27;</span>); <span class="comment">// [&#x27;102300&#x27;, &#x27;1023&#x27;, &#x27;00&#x27;]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实战</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表单验证</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;uname&quot;</span>&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>请输入用户名<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="comment">//  量词是设定某个模式出现的次数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="keyword">var</span> reg = <span class="regexp">/^[a-zA-Z0-9_-]&#123;6,16&#125;$/</span>; <span class="comment">// 这个模式用户只能输入英文字母 数字 下划线 中划线</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="keyword">var</span> uname = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.uname&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="keyword">var</span> span = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;span&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> uname.<span class="property">onblur</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">if</span> (reg.<span class="title function_">test</span>(<span class="variable language_">this</span>.<span class="property">value</span>)) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正确的&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   span.<span class="property">className</span> = <span class="string">&#x27;right&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   span.<span class="property">innerHTML</span> = <span class="string">&#x27;用户名格式输入正确&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误的&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   span.<span class="property">className</span> = <span class="string">&#x27;wrong&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   span.<span class="property">innerHTML</span> = <span class="string">&#x27;用户名格式输入不正确&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤敏感词汇</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> text = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;textarea&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    	div.<span class="property">innerHTML</span> = text.<span class="property">value</span>.<span class="title function_">replace</span>(<span class="regexp">/激情|gay/g</span>, <span class="string">&#x27;**&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><ul>
<li>面向过程v.s. 面向对象<br>面向过程的唯一优点是性能高，一般在单片机中使用。<br>面向对象的优点：封装、继承、多态性，易维护、易复用、易扩展，便于设计出低耦合的系统。</li>
<li>基本概念<br>对象的两个基本概念：<br>1、类：类是对象的类型模板，例如，定义Student类来表示学生，类本身是一种类型，Student表示学生类型，但不表示任何具体的某个学生；<br>2、实例：实例是根据类创建的对象，例如，根据Student类可以创建出xiaoming、xiaohong、xiaojun等多个实例，每个实例表示一个具体的学生，他们全都属于Student类型。</li>
</ul>
<ol start="3">
<li>实例成员就是构造函数内部通过this添加的成员，实例成员只能通过实例化的对象来访问。静态成员是在构造函数本身上添加的成员，静态成员只能通过构造函数来访问。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会唱歌&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh.<span class="property">uname</span>);<span class="comment">//实例成员只能通过实例化的对象来访问</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Star</span>.<span class="property">sex</span> = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Star</span>.<span class="property">sex</span>);<span class="comment">//静态成员只能通过构造函数来访问</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>对象原型<blockquote>
<p>原形：一个对象，我们也称为 prototype 为原型对象（是构造函数的一个属性，它的数据类型是对象）。作用是共享方法，结合构造函数原型的特征，实际开发重往往会将封装的功能函数添加到原型对象中。</p>
<p>构造函数的原型对象：每一个构造函数都有一个名为 prototype 的属性，译成中文是原型的意思，prototype 的是对象类据类型，每个原型对象都具有 constructor 属性代表了该原型对象对应的构造函数，JavaScript 中大多是借助原型对象实现继承的特性。<br>对象都会有一个属性<code>__proto__</code>指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 <code>__proto__ </code>原型的存在。<br><code>__proto__</code>对象原型和原型对象 prototype 是等价的<br><code>__proto__</code>对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype<br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/51b36a21ff124d6b94814cdfe9ac32f8.png" alt="在这里插入图片描述"></p>
</blockquote>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型修改之后一定要为prototype.constructor重新赋值</span></span><br><span class="line"> <span class="title class_">Chinese</span>.<span class="property"><span class="keyword">prototype</span></span> = people;</span><br><span class="line">  <span class="title class_">Chinese</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Chinese</span>;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>constructor构造函数<br>用new调用的函数就是构造函数，这行为叫实例化，没有参数时可以省略new x(这个括号)，返回值为新创建的对象，构造函数内部的return返回值无效。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;通过 new 也能调用函数...&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="keyword">new</span> foo;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构造函数首字母要大写，结合new使用。<br>new 在执行时会做四件事情：<br>① 在内存中创建一个新的空对象。<br>② 让 this 指向这个新的对象。<br>③ 执行构造函数里面的代码，给这个新对象添加属性和方法。<br>④ 返回这个新对象（所以构造函数里面不需要 return ）。</p>
<p>对象原型（ <code>__proto__</code>）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。<br>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。<br>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。<br>如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数</span></span><br><span class="line"> <span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line"> <span class="comment">// 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数</span></span><br><span class="line">   <span class="attr">constructor</span>: <span class="title class_">Star</span>, <span class="comment">// 手动设置指回原来的构造函数</span></span><br><span class="line">   <span class="attr">sing</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会唱歌&#x27;</span>);</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">movie</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会演电影&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> zxy = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zxy)</span><br></pre></td></tr></table></figure>
<p>构造函数好用但存在浪费内存的问题。<br><img src="/images/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.assets/3ace6a255e9847ba832c52efb0fd1a27.png" alt="在这里插入图片描述"></p>
<ul>
<li>构造函数原型prototype<br>构造函数通过原型分配的函数是所有对象所共享的。<br>JavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。<br>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会唱歌&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> zxy = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">19</span>);</span><br><span class="line">ldh.<span class="title function_">sing</span>();<span class="comment">//我会唱歌</span></span><br><span class="line">zxy.<span class="title function_">sing</span>();<span class="comment">//我会唱歌</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实现</li>
</ul>
<ol>
<li>早期JavaScript通过基于构造函数和原型（prototype）来实现面向对象编程。<br>原型是指当我们想要创建xiaoming这个具体的学生时，我们并没有一个Student类型可用。那怎么办？恰好有这么一个现成的对象：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Student</span> = &#123;<span class="comment">//这就是一个对象</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">1.2</span>,</span><br><span class="line">    <span class="attr">run</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; is running...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.<span class="property">__proto__</span> = <span class="title class_">Student</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数创建对象</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>)<span class="comment">//实例化对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh);</span><br></pre></td></tr></table></figure>
<p>xiaoming有自己的name属性，但并没有定义run()方法。不过，由于小明是从Student继承而来，只要Student有run()方法，xiaoming也可以调用<br>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。<br>在JavaScrip代码运行时期，你可以把xiaoming从Student变成Bird，或者变成任何对象。<br>在编写JavaScript代码时，不要直接用<code>obj.__proto__</code>去改变一个对象的原型，并且，低版本的IE也无法使用<code>__proto__</code>。Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型对象:</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Student</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">1.2</span>,</span><br><span class="line">    <span class="attr">run</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; is running...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createStudent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 基于Student原型创建一个新对象:</span></span><br><span class="line">    <span class="keyword">var</span> s = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Student</span>);</span><br><span class="line">    <span class="comment">// 初始化新对象:</span></span><br><span class="line">    s.<span class="property">name</span> = name;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="title function_">createStudent</span>(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">xiaoming.<span class="title function_">run</span>(); <span class="comment">// 小明 is running...</span></span><br><span class="line">xiaoming.<span class="property">__proto__</span> === <span class="title class_">Student</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>方法<br>在一个对象中绑定函数，称为这个对象的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">        <span class="keyword">return</span> y - <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="property">age</span>; <span class="comment">// function xiaoming.age()</span></span><br><span class="line">xiaoming.<span class="title function_">age</span>(); <span class="comment">// 今年调用是25,明年调用就变成26了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拆开写也可以</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="variable language_">this</span>.<span class="property">birth</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">age</span>: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">age</span>(); <span class="comment">// 25, 正常结果</span></span><br><span class="line"><span class="title function_">getAge</span>(); <span class="comment">// NaN</span></span><br><span class="line">getAge.<span class="title function_">apply</span>(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br></pre></td></tr></table></figure>
<p>如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。<br>strict模式下指向undefined<br>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。<br>对普通函数调用，我们通常把this绑定为null<br>另一个与apply()类似的方法是call()，唯一区别是：<br>apply()把参数打包成Array再传入；<br>call()把参数按顺序传入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>)，分别用<span class="title function_">apply</span>()和<span class="title function_">call</span>()实现</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>ES6引入class<br>类名常规首字母大写。<br>创建类 类名后面不要加小括号<br>constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数，构造函数不需要加function<br>多个函数方法之间不需要添加逗号分隔</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1 使用class关键字</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">name</span> &#123;</span><br><span class="line">  <span class="comment">// class body</span></span><br><span class="line">&#125;     </span><br><span class="line"><span class="comment">//步骤2使用定义的类创建实例  注意new关键字</span></span><br><span class="line"><span class="keyword">var</span> xx = <span class="keyword">new</span> <span class="title function_">name</span>();     </span><br><span class="line"><span class="comment">//类中封装的并不是变量和函数，因此不能使用关键字let、const、var</span></span><br><span class="line"><span class="comment">// 1. 创建类 class  创建一个 明星类</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">   <span class="comment">// 类的共有属性放到 constructor 里面，返回实例对象</span></span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">	   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">	   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//static 静态属性或方法</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//注意,方法与方法之间不需要添加逗号</span></span><br><span class="line">    <span class="title function_">sing</span>(<span class="params">song</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">uname</span> + <span class="string">&#x27;唱&#x27;</span> + song);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">   <span class="comment">// 2. 利用类创建对象 new</span></span><br><span class="line">   <span class="keyword">var</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(ldh);</span><br></pre></td></tr></table></figure>
<ul>
<li>继承</li>
</ul>
<ol>
<li>继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的.如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)</li>
<li>如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用父类的构造函数,super 必须在子类this之前调用</li>
<li>时刻注意this的指向问题,类里面的共有的属性和方法一定要加this。constructor中的this指向的是new出来的实例对象 ,自定义的方法,一般也指向的new出来的实例对象,绑定事件之后this指向的就是触发事件的事件源</li>
<li>在 JavaScript 中，that 不是一个关键字或内置对象，但在 ES6 之前的代码中，开发者常使用 that 作为一个变量名，用来保存 this 的引用，特别是在 回调函数 或 闭包 中，以避免 this 绑定丢失的问题。<code>var that = this; // 保存 this 的引用</code></li>
<li>在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象</li>
<li>super关键字 用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;   </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Son</span>  <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;  </span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"><span class="comment">//子类使用super关键字访问父类的方法</span></span><br><span class="line"><span class="comment">//super 函数的作用是可以将子类实例化时获得的参数传入父类的构造函数之中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">	   <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">	   <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">   	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//子元素继承父类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">   		 <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    		<span class="variable language_">super</span>(x, y); <span class="comment">//使用super调用了父类中的构造函数</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    son.<span class="title function_">sum</span>(); <span class="comment">//结果为3</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 父类有加法方法</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">	   <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">	   <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">   	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 子类继承父类加法方法 同时 扩展减法方法</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">	   <span class="comment">// 利用super 调用父类的构造函数 super 必须在子类this之前调用,放到this之后会报错</span></span><br><span class="line">	   <span class="variable language_">super</span>(x, y);</span><br><span class="line">	   <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">	   <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">subtract</span>(<span class="params"></span>) &#123;</span><br><span class="line">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span> - <span class="variable language_">this</span>.<span class="property">y</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">son.<span class="title function_">subtract</span>(); <span class="comment">//2</span></span><br><span class="line">son.<span class="title function_">sum</span>();<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//super可以调用父类普通函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"> <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&#x27;我是爸爸&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123; <span class="comment">// 这样子类就继承了父类的属性和方法</span></span><br><span class="line"> <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// super.say() super 调用父类的方法</span></span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">say</span>() + <span class="string">&#x27;的儿子&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> damao = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(damao.<span class="title function_">say</span>());</span><br></pre></td></tr></table></figure>
<h1 id="存储-自定义属性"><a href="#存储-自定义属性" class="headerlink" title="存储-自定义属性"></a>存储-自定义属性</h1><p>自定义属性: 由程序员自己添加的属性,在DOM对象中找不到</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getAttribute</span>(<span class="string">&#x27;属性名&#x27;</span>) <span class="comment">// 获取自定义属性</span></span><br><span class="line"><span class="title function_">setAttribute</span>(<span class="string">&#x27;属性名&#x27;</span>, <span class="string">&#x27;属性值&#x27;</span>) <span class="comment">// 设置自定义属性</span></span><br><span class="line"><span class="title function_">removeAttribute</span>(<span class="string">&#x27;属性名&#x27;</span>) <span class="comment">// 删除自定义属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种 data-自定义属性</span></span><br><span class="line"><span class="comment">//传统的自定义属性没有专门的定义规则,开发者随意定值,不够规范</span></span><br><span class="line"><span class="comment">//在html5中推出来了专门的data-自定义属性	</span></span><br><span class="line"><span class="comment">//在标签上一律以data-开头</span></span><br><span class="line"><span class="comment">//在DOM对象上一律以dataset对象方式获取</span></span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&#x27;box&#x27;</span> data-id=<span class="string">&#x27;10&#x27;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">dataset</span>.<span class="property">id</span>)</span><br></pre></td></tr></table></figure>

            </div>
        </div>
    </article>

    
    
<nav class="article-nav">
  
    <a href="/2025/07/28/Bootsrap/" id="article-nav-newer" class="article-nav-link-wrap prev">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Bootsrap
        
      </div>
    </a>
  
  
    <a href="/2025/07/20/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91ES6%E5%A4%A7%E5%85%A8/" id="article-nav-older" class="article-nav-link-wrap next">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ES6一本通</div>
    </a>
  
</nav>

    

    
</div>
    </div>
    <footer class="site-footer">
        <div class="global-width">
            <ul class="site-widget">
                
                <li class="widget widget-tag">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/English/" rel="tag">English</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/basics/" rel="tag">basics</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/frontend/" rel="tag">frontend</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/projects/" rel="tag">projects</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tags/" rel="tag">tags</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

                </li>
                
                <li class="widget widget-category">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/daily-report/">daily_report</a><span class="category-list-count">52</span></li></ul>
    </div>
  </div>

                </li>
                
                <li class="widget widget-recent_posts">
                    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-body">
      <ul>
        
          <li>
            <a href="/2025/07/28/Bootsrap/">Bootsrap</a>
          </li>
        
          <li>
            <a href="/2025/07/20/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91JS%E5%A4%A7%E5%85%A8/">JS一本通</a>
          </li>
        
          <li>
            <a href="/2025/07/20/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91ES6%E5%A4%A7%E5%85%A8/">ES6一本通</a>
          </li>
        
          <li>
            <a href="/2025/07/12/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%85%A8/">包管理工具</a>
          </li>
        
          <li>
            <a href="/2025/07/09/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91htmlcss%E5%A4%A7%E5%85%A8/">HTML_CSS_Bootstrap_Emmet</a>
          </li>
        
      </ul>
    </div>
  </div>

                </li>
                
            </ul>
        </div>
        <div class="site-info">
            <address>
                &copy; 2014 <a href="https://70v-yoyo.github.io">Yoyo&#39;s blog</a> All Right Reserved. <br/>
                Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a>. Theme by <a target="_blank" rel="noopener" href="http://zzoman.com">ZZOMAN</a>
                <p><a target="_blank" href="https://github.com/70v-Yoyo">My github</a></p>
            </address>
        </div>
    </footer> 
    
    
    <script src="/libs/jquery-1.11.3.min.js" type="text/javascript"></script>
    
    <script src="/libs/fancybox/jquery.fancybox.js" type="text/javascript"></script>
    
    <script src="/js/site_init.js" type="text/javascript"></script>
     
    <noscript>
        <style>
            article {
                position: absolute;
                width: 0;
                height: 0;
                overflow: hidden;
                opacity: 0;
            }

        </style>
        <h1>JS已被禁用</h1>
    </noscript>
<!-- hexo injector body_end start -->
    <script>
      (function() {
        function moveElementIfSmallScreen() {
          const toc = document.getElementById('fixed-toc-container');
          const article = document.querySelector("article");
          const toggleBtn = document.getElementById('toggle_btn');
          if (!toc || !article) return;
          if (window.innerWidth < 1024 && article.firstElementChild !== toc) {
            console.log('small screen!!')
            
            article.insertBefore(toc, article.firstChild);//移动节点，而非复制
            
            toggleBtn.style.display='none';
            // 替换样式：取消 fixed，设置适合正文的样式
            toc.style.position = 'relative';
            toc.style.top = '';
            toc.style.left = '';
            toc.style.width = '100%';
            toc.style.maxHeight = 'none';
            toc.style.overflowY = 'visible';
            toc.style.overflowX = 'visible';
            toc.style.padding = '1em';
            toc.style.borderLeft = 'none';
            toc.style.borderBottom = '1px solid #ddd';
            toc.style.background = '#f9f9f9';
            toc.style.opacity = '1';
            toc.style.zIndex = '9999';
            toc.style.boxShadow = 'none';
            toc.style.margin = '1rem';
            toc.style.paddingTop= '2rem';
          }
        }
        window.addEventListener("DOMContentLoaded", moveElementIfSmallScreen);
        window.addEventListener("resize", moveElementIfSmallScreen);
      })();
    </script>
  <!-- hexo injector body_end end -->
    <div id="fixed-toc-container" style="
      position: fixed;
      top: 0vh;
      left: 0px;
      width: 15rem;
      max-height: 80vh;
      overflow-y: auto;
      overflow-x: auto;
      padding: 10px;
      border-left: 2px solid #ccc;
      font-size: 14px;
      line-height: 1.5;
      background: #fff;
      opacity:0.8;
      z-index: 9999;
      box-shadow:
        0 2px 4px rgba(0, 0, 0, 0.05),  /* 第一层：近处柔和 */
        0 8px 16px rgba(0, 0, 0, 0.08); /* 第二层：远处扩散 */
    ">
      <strong>Contents</strong>
      <div id="toggle_btn" style="
      position:absolute;
      right:1rem;
      display:inline-block;
      width:2rem;
      text-align:center;
      border:1px solid #ccc;
      "><</div>
      <ul id="fixed-toc-list" style="list-style: none; padding-left: 10px;"></ul>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const nav = document.querySelector('nav');
        if (nav) {
          const navBottom = nav.getBoundingClientRect().bottom;//浏览器JS API
          console.log('nav bottom:', navBottom);
          // 设置toc元素 top = nav bottom
          const toc = document.querySelector('#fixed-toc-container');
          if (toc) {
            toc.style.top = navBottom + 'px';
            toc.style.maxHeight=window.innerHeight - navBottom.getBoundingClientRect().bottom;
          }
        }
      });

      const myDiv = document.getElementById('toggle_btn');
      var tocList=document.getElementById("fixed-toc-list");
      var tocContainer=document.getElementById("fixed-toc-container");
      function handleClickBtn() {
        console.log('Div 被点击了！');
        if(myDiv.textContent==='<'){
          myDiv.textContent ='>'
          tocList.style.display='none'
          tocContainer.style.width='11rem'
        }else{
          myDiv.textContent ='<'
          tocList.style.display='block'
          tocContainer.style.width='15rem'
        }
          
      }


      myDiv.addEventListener('click', handleClickBtn);// 绑定点击事件


      (function() {
      const Patternstr = "/*\\d{4}/\\d{2}/\\d{2}/.*"; //本身是字符串插入，所以对符号要转义
      //"^//*"->"/"
      //"/.*"->".*"
      //JS引擎中""转义
      //正则表达式引擎也是""转义
      const dataPattern = new RegExp(Patternstr);
      const path = window.location.pathname;
      console.log(dataPattern.toString(),path,dataPattern.test(path));//控制台在渲染时省略了反斜杠的可视表示。
      if (!dataPattern.test(path)&&(path==='/'||path==='index.html')) {
        console.log('no toc')
        let toc = document.getElementById('fixed-toc-container');
        if (toc) toc.style.display = 'none';
        return;
      }
        var content = document.querySelector('body');
        console.log('content',content)
        //var tocList = document.getElementById('fixed-toc-list');
        if (!content || !tocList) {
          document.getElementById('fixed-toc-container').style.display = 'none';
          return;
        }
        var headings = content.querySelectorAll('h1, h2, h3, h4');
        console.log('headings',headings)
        if(headings){
          const h1Element=headings[0];
          const rect = h1Element.getBoundingClientRect();
          if(rect.left<150){
           tocContainer.style.right='0px';
           tocContainer.style.left = 'auto'; // 移除内联的 left 样式
            //不是设置right:0 就替换left:0 需要移除
            console.log('to right')
          }
          console.log(rect.left,'150')
        }
        
        if (headings.length === 0) {
          document.getElementById('fixed-toc-container').style.display = 'none';
          return;
        }
        headings.forEach(function(heading, i) {
          if (!heading.id) {
            heading.id = 'heading-' + i;
          }
        });
        headings.forEach(function(heading) {
          var level = parseInt(heading.tagName.substring(1));
          var li = document.createElement('li');
          li.style.marginLeft = (level - 1) * 15 + 'px';
          var a = document.createElement('a');
          a.href = '#' + heading.id;
          a.textContent = heading.textContent;
          a.style.color = '#555';
          a.style.textDecoration = 'none';
          a.onmouseover = function() { a.style.textDecoration = 'underline'; };
          a.onmouseout = function() { a.style.textDecoration = 'none'; };
          li.appendChild(a);
          tocList.appendChild(li);
        });
      })();
    </script>
  </body>
</html>
